<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Avatar Overlay</title>
  <style>
    :root {
      --primary: #9146ff;
      --primary-dark: #7c3aed;
      --secondary: #fbbf24;
      --accent: #10b981;
      --bg-dark: #0f172a;
      --bg-card: #111827;
      --text-primary: #e2e8f0;
      --text-secondary: #9ca3af;
      --border: #374151;
    }

    html, body { 
      height: 100%; 
      margin: 0; 
      background: transparent; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    body { 
      overflow: hidden; 
    }
    
    #stage {
      position: fixed;
      left: 0; 
      right: 0; 
      bottom: 0;
      height: 25%; /* —É–≤–µ–ª–∏—á–∏–ª –≤—ã—Å–æ—Ç—É –¥–ª—è –ª—É—á—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏ */
      pointer-events: none;
      background: linear-gradient(to top, rgba(15, 23, 42, 0.1), transparent);
    }
    
    .avatar {
      position: absolute;
      bottom: 0;
      width: 140px; /* —É–≤–µ–ª–∏—á–∏–ª —Ä–∞–∑–º–µ—Ä */
      height: 180px;
      transform: translateZ(0);
      image-rendering: -webkit-optimize-contrast;
      /* Movement is now controlled by JavaScript for constant speed */
    }

    .food-game-avatar .avatar {
      transition: none;
    }
    /* –£–±–∏—Ä–∞–µ–º CSS —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ opacity - —Ç–µ–ø–µ—Ä—å –≤—Å–µ —á–µ—Ä–µ–∑ JavaScript */
    .avatar .layer {
      opacity: 0;
    }
    .avatar .layer.static {
      opacity: 1;
    }
    .avatar.laughing {
      animation: laughShake 1.5s ease-in-out;
    }
    
    /* –°—Ç–∏–ª–∏ –¥–ª—è —Å–æ—Å—Ç–æ—è–Ω–∏—è tired */
    .avatar.tired {
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
      opacity: 0.8;
    }
    
    .avatar.normal {
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
      opacity: 1;
    }
    .avatar .gift {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -60%);
      width: 40px; /* —É–≤–µ–ª–∏—á–∏–ª —Ä–∞–∑–º–µ—Ä */
      height: 40px;
      z-index: 200;
      pointer-events: none;
      animation: giftFloat 3s cubic-bezier(0.4, 0, 0.2, 1);
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    }
    
    .avatar .gift img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      animation: giftRotate 3s ease-in-out;
    }
    
    @keyframes giftFloat {
      0% { 
        transform: translate(-50%, -60%) scale(0.3);
        opacity: 0;
      }
      15% { 
        transform: translate(-50%, -60%) scale(1.3);
        opacity: 1;
      }
      25% { 
        transform: translate(-50%, -60%) scale(1);
        opacity: 1;
      }
      75% { 
        transform: translate(-50%, -60%) scale(1);
        opacity: 1;
      }
      100% { 
        transform: translate(-50%, -60%) scale(0.7);
        opacity: 0;
      }
    }
    
    @keyframes giftRotate {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(-5deg); }
      75% { transform: rotate(5deg); }
    }

    /* Race styles */
    .race-track {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: transparent; /* –£–±–∏—Ä–∞–µ–º —Ñ–æ–Ω */
      z-index: 1000;
      display: none;
      /* backdrop-filter: blur(2px); */ /* –£–±–∏—Ä–∞–µ–º —Ä–∞–∑–º—ã—Ç–∏–µ —Ñ–æ–Ω–∞ */
    }

    .race-avatar {
      position: fixed;
      top: 50%;
      left: 20px;
      transform: translateY(-50%);
      z-index: 1001;
      transition: left 0.1s cubic-bezier(0.4, 0, 0.2, 1);
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.4));
    }

    .race-avatar .avatar {
      position: relative;
      left: 0 !important;
      transform: scale(0.9);
      animation: raceBounce 0.6s ease-in-out infinite alternate;
    }
    
    @keyframes raceBounce {
      0% { transform: scale(0.9) translateY(0px); }
      100% { transform: scale(0.9) translateY(-3px); }
    }

    .race-countdown {
      position: fixed;
      top: 30%;
      left: 50%;
      transform: translateX(-50%);
      font-size: 64px;
      font-weight: 800;
      color: var(--secondary);
      text-shadow: 0 0 20px rgba(251, 191, 36, 0.8), 2px 2px 8px rgba(0,0,0,0.9);
      z-index: 1002;
      display: none;
      text-align: center;
      animation: countdownPulse 1s ease-in-out infinite;
      font-family: 'Courier New', monospace;
    }
    
    @keyframes countdownPulse {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.1); }
    }

    .race-winner {
      position: fixed;
      top: calc(50% - 80px);
      left: 50%;
      transform: translateX(-50%);
      font-size: 48px;
      font-weight: 800;
      color: var(--secondary);
      text-shadow: 0 0 30px rgba(251, 191, 36, 1), 2px 2px 8px rgba(0,0,0,0.9);
      z-index: 1003;
      display: none;
      text-align: center;
      animation: winnerGlow 2s ease-in-out infinite alternate;
      font-family: 'Courier New', monospace;
    }
    
    @keyframes winnerGlow {
      0% { 
        text-shadow: 0 0 30px rgba(251, 191, 36, 1), 2px 2px 8px rgba(0,0,0,0.9);
        transform: translateX(-50%) scale(1);
      }
      100% { 
        text-shadow: 0 0 40px rgba(251, 191, 36, 1), 0 0 60px rgba(251, 191, 36, 0.8), 2px 2px 8px rgba(0,0,0,0.9);
        transform: translateX(-50%) scale(1.05);
      }
    }

    /* Food Game Styles */
    .food-game-area {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      display: none;
    }

    /* Race Plan Styles */
    .race-plan-area {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;                 /* –ø—Ä–∏–≤—è–∑–∫–∞ –∫ –Ω–∏–∂–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü–µ */
      height: var(--race-h, 360px);  /* —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞ —á–µ—Ä–µ–∑ css-–ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
      width: 100%;
      background: linear-gradient(180deg, rgba(30, 58, 138, 0.8), rgba(59, 130, 246, 0.4));
      z-index: 1000;
      display: none;
      backdrop-filter: blur(2px);
      overflow: hidden;          /* —Å–∫—Ä—ã–≤–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã, –≤—ã—Ö–æ–¥—è—â–∏–µ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã */
    }

    /* –í–ù–ï–®–ù–ò–ô: –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ (–ù–ï –¥–æ–ª–∂–Ω–æ –∏–º–µ—Ç—å –¥—Ä—É–≥–∏—Ö transform –∫—Ä–æ–º–µ translate) */
    .race-plan-avatar {
      position: absolute;
      z-index: 1001;
      will-change: transform; /* –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è */
      backface-visibility: hidden; /* –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ */
      filter: none; /* –£–±–∏—Ä–∞–µ–º –≤—Å–µ —Ñ–∏–ª—å—Ç—Ä—ã —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Å–ª–µ–¥–æ–≤ */
      background: transparent; /* –£–±–∏—Ä–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ñ–æ–Ω—ã */
      width: var(--avatar-w, 128px);
      height: var(--avatar-h, 128px);
    }

    /* –í–ù–£–¢–†–ï–ù–ù–ò–ô: –º–∞—Å—à—Ç–∞–± + —ç—Ñ—Ñ–µ–∫—Ç—ã */
    .race-plan-avatar .avatar {
      position: relative;
      left: 0 !important;
      transform-origin: top left;
      transform: scale(0.4); /* —Ç–≤–æ–π –±–∞–∑–æ–≤—ã–π –º–∞—Å—à—Ç–∞–± */
      animation: none; /* –£–±–∏—Ä–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è */
      display: block; /* –í–∞–∂–Ω–æ –¥–ª—è –≤—ã—Å–æ—Ç—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ */
    }

    /* –ê–Ω–∏–º–∞—Ü–∏—è –¥–≤–∏–∂–µ–Ω–∏—è –º–µ–∂–¥—É —É—Ä–æ–≤–Ω—è–º–∏ */
    .race-plan-avatar.moving .avatar {
      transform: scale(0.45); /* –ù–µ–±–æ–ª—å—à–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ */
      transition: transform 0.15s ease-out;
    }


    /* –ê–Ω–∏–º–∞—Ü–∏—è –∫–æ–ª–ª–∏–∑–∏–∏ - —Ç–æ–ª—å–∫–æ –Ω–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–º —É–∑–ª–µ */
    .race-plan-avatar .avatar.collision {
      animation: planeCollision 0.5s ease-in-out;
    }

    @keyframes planeCollision {
      0%,100% { transform: scale(0.4) translateY(0) }
      25%     { transform: scale(0.4) translateY(-10px) rotate(-5deg) }
      50%     { transform: scale(0.4) translateY(5px)  rotate(5deg) }
      75%     { transform: scale(0.4) translateY(-5px) rotate(-3deg) }
    }

    /* –°–æ—Å—Ç–æ—è–Ω–∏–µ "–º–µ—Ä—Ç–≤—ã–π" –∞–≤–∞—Ç–∞—Ä */
    .race-plan-avatar.out {
      opacity: 0.5;
      filter: grayscale(100%);
    }

    /* –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–π (—Å–µ—Ä–¥–µ—á–∫–∏) */
    .race-plan-avatar .lives-display {
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 2px;
      z-index: 1002;
      pointer-events: none;
    }

    .race-plan-avatar .lives-display .heart {
      width: 16px;
      height: 16px;
      background: #ff6b6b;
      clip-path: polygon(50% 100%, 0% 0%, 100% 0%);
      border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
      animation: heartbeat 1s ease-in-out infinite;
    }

    .race-plan-avatar .lives-display .heart.empty {
      background: #666;
      animation: none;
    }

    @keyframes heartbeat {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }


    @keyframes planeFloat {
      0% { transform: scale(0.4) translateY(0px); }
      100% { transform: scale(0.4) translateY(-5px); }
    }

    @keyframes planeCollision {
      0%, 100% { transform: scale(0.4) translateY(0px); }
      25% { transform: scale(0.4) translateY(-10px) rotate(-5deg); }
      50% { transform: scale(0.4) translateY(5px) rotate(5deg); }
      75% { transform: scale(0.4) translateY(-5px) rotate(-3deg); }
    }
    
    @keyframes finishLinePulse {
      0%, 100% { 
        opacity: 0.8; 
        box-shadow: 0 0 10px #ffd700; 
      }
      50% { 
        opacity: 1; 
        box-shadow: 0 0 20px #ffd700, 0 0 30px #ffd700; 
      }
    }

    .obstacle {
      position: absolute;
      z-index: 1001;
      transition: transform 0.1s ease-out; /* –ü–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ */
      filter: none; /* –£–±–∏—Ä–∞–µ–º —Ñ–∏–ª—å—Ç—Ä—ã —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Å–ª–µ–¥–æ–≤ */
      will-change: transform; /* –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è */
      backface-visibility: hidden; /* –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ */
      transform-style: preserve-3d;
      animation: none; /* –£–±–∏—Ä–∞–µ–º –ª—é–±—ã–µ –∞–Ω–∏–º–∞—Ü–∏–∏ */
      transform-origin: center center;
    }

    .obstacle.bird {
      width: 40px;
      height: 30px;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 30"><path d="M5 15c0-5 5-10 10-10s10 5 10 10c0 3-2 5-5 5s-5-2-5-5z" fill="%23ff6b6b"/><path d="M25 15c0-3 2-5 5-5s5 2 5 5c0 2-1 3-3 3s-3-1-3-3z" fill="%23ff6b6b"/><circle cx="8" cy="12" r="2" fill="%23000"/><path d="M15 20l-2-2 2-2" stroke="%23000" stroke-width="1" fill="none"/></svg>') no-repeat center;
      background-size: contain;
    }

    .obstacle.plane {
      width: 50px;
      height: 35px;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 35"><path d="M5 17.5c0-5 8-10 15-10s15 5 15 10c0 3-3 5-7 5s-7-2-7-5z" fill="%23666"/><path d="M25 17.5c0-2 3-4 7-4s7 2 7 4c0 1-1 2-3 2s-3-1-3-2z" fill="%23666"/><circle cx="10" cy="15" r="1.5" fill="%23000"/><path d="M20 25l-3-3 3-3" stroke="%23000" stroke-width="1" fill="none"/></svg>') no-repeat center;
      background-size: contain;
    }

    .obstacle.rock {
      width: 60px;
      height: 60px;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 60"><path d="M30 10c-8 0-15 7-15 15s7 15 15 15 15-7 15-15-7-15-15-15zm0 25c-5 0-10-5-10-10s5-10 10-10 10 5 10 10-5 10-10 10z" fill="%23888"/><circle cx="25" cy="25" r="3" fill="%23999"/><circle cx="35" cy="30" r="2" fill="%23777"/></svg>') no-repeat center;
      background-size: contain;
    }

    .race-plan-countdown {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 72px;
      font-weight: bold;
      color: #3b82f6;
      text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
      z-index: 1002;
      display: none;
    }

    .race-plan-winner {
      position: fixed;
      top: calc(50% - 80px);
      left: 50%;
      transform: translateX(-50%);
      font-size: 48px;
      font-weight: bold;
      color: #fbbf24;
      text-shadow: 0 0 20px rgba(251, 191, 36, 0.8);
      z-index: 1002;
      display: none;
    }

    /* Level indicators */
    .level-indicator {
      position: fixed;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 1003;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .level-line {
      width: 4px;
      height: 60px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
      position: relative;
    }

    .level-line.active {
      background: #3b82f6;
      box-shadow: 0 0 10px rgba(59, 130, 246, 0.8);
    }

    .level-label {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      color: white;
      font-size: 12px;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }

    .food-game-avatar {
      position: absolute;
      bottom: 20px;
      z-index: 1001;
      transform-origin: center;
      will-change: left;
      contain: paint;
      backface-visibility: hidden;
    }

    .carrot {
      position: absolute;
      width: 50px; /* —É–≤–µ–ª–∏—á–∏–ª —Ä–∞–∑–º–µ—Ä */
      height: 50px;
      background: url('/parts/carrot.svg') no-repeat center;
      background-size: contain;
      z-index: 1001;
      transition: opacity 0.3s ease;
      filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.3));
      animation: carrotFloat 2s ease-in-out infinite;
    }
    
    @keyframes carrotFloat {
      0%, 100% { transform: translateY(0px) rotate(0deg); }
      50% { transform: translateY(-5px) rotate(2deg); }
    }
    
    /* Responsive Design for Overlay */
    @media (max-width: 768px) {
      .avatar {
        width: 120px;
        height: 150px;
      }
      
      .race-avatar .avatar {
        transform: scale(0.7);
      }
      
      .race-countdown {
        font-size: 48px;
      }
      
      .race-winner {
        font-size: 36px;
      }
      
      .carrot {
        width: 40px;
        height: 40px;
      }
      
      .avatar .gift {
        width: 32px;
        height: 32px;
      }
    }
    
    @media (max-width: 480px) {
      .avatar {
        width: 100px;
        height: 130px;
      }
      
      .race-avatar .avatar {
        transform: scale(0.6);
      }
      
      .race-countdown {
        font-size: 36px;
      }
      
      .race-winner {
        font-size: 28px;
      }
      
      .carrot {
        width: 35px;
        height: 35px;
      }
      
      .avatar .gift {
        width: 28px;
        height: 28px;
      }
    }

    .carrot.grounded {
      opacity: 0.9;
      transform: scale(1.2);
    }

    /* Score counter styles */
    .score-counter {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: #00ff00;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 14px;
      font-weight: bold;
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      text-shadow: 0 0 4px rgba(0, 255, 0, 0.8);
      border: 2px solid #00ff00;
      white-space: nowrap;
      display: block;
    }

    .food-game-avatar .score-counter {
      position: absolute;
      top: -200px;
      left: 50%;
      transform: translateX(-50%);
      transform-origin: center;
      pointer-events: none;
      z-index: 1000;
      font-size: 7px;
      padding: 2px 4px;
    }

    .score-counter.updated {
      background: rgba(0, 255, 0, 0.9);
      color: #000;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
    }


    .food-game-countdown {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 72px;
      font-weight: bold;
      color: #ff6b6b;
      text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
      z-index: 1002;
      display: none;
    }

    .food-game-winner {
      position: fixed;
      top: calc(50% - 80px);
      left: 50%;
      transform: translateX(-50%);
      font-size: 48px;
      font-weight: bold;
      color: #fbbf24;
      text-shadow: 0 0 20px rgba(251, 191, 36, 0.8);
      z-index: 1002;
      display: none;
    }

    .avatar .emoji {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, 50%);
      font-size: 24px;
      z-index: 100;
      pointer-events: none;
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      color: white;
    }
    
    .avatar .emoji img {
      width: 28px;
      height: 28px;
      object-fit: contain;
    }
    
    /* –°—Ç–∏–ª–∏ –¥–ª—è –∑–Ω–∞–∫–∞ –≤–æ–ø—Ä–æ—Å–∞ */
    .avatar .question-mark {
      position: absolute;
      left: 50%;
      bottom: 100%;
      transform: translate(-50%, -30px);
      font-size: 40px;
      z-index: 100;
      pointer-events: none;
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      font-weight: bold;
      color: #ff4444;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      animation: questionPulse 2s ease-in-out infinite;
    }
    
    @keyframes questionPulse {
      0%, 100% { 
        transform: translate(-50%, -30px) scale(1);
        opacity: 1;
      }
      50% { 
        transform: translate(-50%, -30px) scale(1.1);
        opacity: 0.8;
      }
    }
    .avatar.walking.left .layer.walk1,
    .avatar.walking.left .layer.walk2 {
      transform: scaleX(-1);
    }
    
    /* CSS –∞–Ω–∏–º–∞—Ü–∏–∏ —Ö–æ–¥—å–±—ã —É–±—Ä–∞–Ω—ã - —Ç–µ–ø–µ—Ä—å —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ JavaScript */
    @keyframes laughShake {
      0%, 100% { transform: translateX(0); }
      10% { transform: translateX(-8px); }
      20% { transform: translateX(8px); }
      30% { transform: translateX(-8px); }
      40% { transform: translateX(8px); }
      50% { transform: translateX(-6px); }
      60% { transform: translateX(6px); }
      70% { transform: translateX(-4px); }
      80% { transform: translateX(4px); }
      90% { transform: translateX(-2px); }
    }
    .layer { position: absolute; left: 0; bottom: 0; width: 100%; height: 100%; }
    .layer[alt="body"] { z-index: 1; }
    .layer[alt="clothes"] { z-index: 2; }
    .layer[alt="face"] { z-index: 3; }
    .layer[alt="others"] { z-index: 4; }
    
    /* Walking animation layers */
    .layer[alt="body_walk1"] { z-index: 1; }
    .layer[alt="clothes_walk1"] { z-index: 2; }
    .layer[alt="face_walk1"] { z-index: 3; }
    .layer[alt="others_walk1"] { z-index: 4; }
    
    .layer[alt="body_walk2"] { z-index: 1; }
    .layer[alt="clothes_walk2"] { z-index: 2; }
    .layer[alt="face_walk2"] { z-index: 3; }
    .layer[alt="others_walk2"] { z-index: 4; }
    
    /* Tired layers */
    .layer[alt="body_tired"] { z-index: 1; }
    .layer[alt="clothes_tired"] { z-index: 2; }
    .layer[alt="face_tired"] { z-index: 3; }
    .layer[alt="others_tired"] { z-index: 4; }
    
    /* Sign layers */
    .layer[alt="body_sign"] { z-index: 1; }
    .layer[alt="clothes_sign"] { z-index: 2; }
    .layer[alt="face_sign"] { z-index: 3; }
    .layer[alt="others_sign"] { z-index: 4; }
    
    /* Hi layers */
    .layer[alt="body_hi"] { z-index: 1; }
    .layer[alt="clothes_hi"] { z-index: 2; }
    .layer[alt="face_hi"] { z-index: 3; }
    .layer[alt="others_hi"] { z-index: 4; }
    .label {
      position: absolute; left: 50%; bottom: 100%; transform: translate(-50%, -6px);
      color: black; font: 600 14px/1.2 -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      text-shadow: 0 1px 2px rgba(255,255,255,.9);
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <div id="stage"></div>
  
  <!-- Race elements -->
  <div class="race-track" id="raceTrack"></div>
  <div class="race-countdown" id="raceCountdown"></div>
  <div class="race-winner" id="raceWinner"></div>

  <!-- Food Game Elements -->
  <div class="food-game-area" id="foodGameArea"></div>
  <div class="food-game-countdown" id="foodGameCountdown"></div>
  <div class="food-game-winner" id="foodGameWinner"></div>

  <!-- Race Plan Elements -->
  <div class="race-plan-area" id="racePlanArea"></div>
  <div class="race-plan-countdown" id="racePlanCountdown"></div>
  <div class="race-plan-winner" id="racePlanWinner"></div>
  
  <div class="level-indicator" id="levelIndicator" style="display: none;">
    <div class="level-line" data-level="0">
      <div class="level-label">–í–µ—Ä—Ö</div>
    </div>
    <div class="level-line active" data-level="1">
      <div class="level-label">–°—Ä–µ–¥–Ω–∏–π</div>
    </div>
    <div class="level-line" data-level="2">
      <div class="level-label">–ù–∏–∑</div>
    </div>
  </div>

  <script>
    // Default assets - will be updated when user avatar is loaded
    let ASSETS = {
      body: '/parts/body/body_skin_1.png',
      face: '/parts/face/face_skin_1.png',
      clothes: '/parts/clothes/clothes_type_1.png',
      others: '/parts/others/others_1.png'
    };

    // User avatar cache
    const userAvatars = new Map();

    const overlayAuth = {
      token: null,
      streamerId: null
    };

    function withStreamerAuth(payload = {}) {
      const result = { ...payload };
      if (overlayAuth.streamerId) {
        result.streamerId = overlayAuth.streamerId;
      }
      if (overlayAuth.token) {
        result.token = overlayAuth.token;
      }
      return result;
    }

    // Avatar state management functions
    function stopAvatarIntervals(avatar) {
      // –≤—ã–∫–ª—é—á–∞–µ–º –ª—é–±—ã–µ —Ä–∞–Ω–µ–µ –∑–∞–ø—É—â–µ–Ω–Ω—ã–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã
      if (avatar.dataset.walkInterval) {
        clearInterval(Number(avatar.dataset.walkInterval));
        delete avatar.dataset.walkInterval;
      }
      if (avatar.dataset.tiredInterval) {
        clearInterval(Number(avatar.dataset.tiredInterval));
        delete avatar.dataset.tiredInterval;
      }
      if (avatar.dataset.animationInterval) {
        clearInterval(Number(avatar.dataset.animationInterval));
        delete avatar.dataset.animationInterval;
      }
    }

    function showOnlyLayers(avatar, { staticOn = false, walk1On = false, walk2On = false, tiredOn = false, signOn = false, hiOn = false }) {
      avatar.querySelectorAll('.layer.static').forEach(l => l.style.setProperty('opacity', staticOn ? '1' : '0', 'important'));
      avatar.querySelectorAll('.layer.walk1').forEach(l => l.style.setProperty('opacity', walk1On ? '1' : '0', 'important'));
      avatar.querySelectorAll('.layer.walk2').forEach(l => l.style.setProperty('opacity', walk2On ? '1' : '0', 'important'));
      avatar.querySelectorAll('.layer.tired').forEach(l => l.style.setProperty('opacity', tiredOn ? '1' : '0', 'important'));
      avatar.querySelectorAll('.layer.sign').forEach(l => l.style.setProperty('opacity', signOn ? '1' : '0', 'important'));
      avatar.querySelectorAll('.layer.hi').forEach(l => l.style.setProperty('opacity', hiOn ? '1' : '0', 'important'));
    }

    function startWalkingAnimation(avatar, fps = 8) {
      // –∑–∞—â–∏—Ç–∞ –æ—Ç –¥–≤–æ–π–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞
      if (avatar.dataset.walkInterval) return;

      let isWalk1 = true;

      const interval = setInterval(() => {
        if (isWalk1) {
          showOnlyLayers(avatar, { walk1On: true, walk2On: false });
        } else {
          showOnlyLayers(avatar, { walk1On: false, walk2On: true });
        }
        isWalk1 = !isWalk1;
      }, 1000 / fps);

      avatar.dataset.walkInterval = String(interval);
    }

    function setAvatarState(avatar, state) {
      // —á–∏—Å—Ç–∏–º —Ö–≤–æ—Å—Ç—ã –ø—Ä–æ—à–ª—ã—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π
      stopAvatarIntervals(avatar);
      avatar.classList.remove('static', 'walking', 'tired');

      switch (state) {
        case 'static': {
          avatar.classList.add('static');
          showOnlyLayers(avatar, { staticOn: true, walk1On: false, walk2On: false, tiredOn: false, signOn: false, hiOn: false });
          // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é —É—Å—Ç–∞–ª–æ—Å—Ç–∏ –µ—Å–ª–∏ –±—ã–ª–∞
          if (avatar.dataset.tiredInterval) {
            clearInterval(parseInt(avatar.dataset.tiredInterval));
            avatar.dataset.tiredInterval = '';
            avatar.style.transform = '';
          }
          break;
        }
        case 'walking': {
          avatar.classList.add('walking');
          // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–∞–¥—Ä walk1 –∏ –∑–∞–ø—É—Å–∫–∞–µ–º —Ç—É–º–±–ª–µ—Ä –∫–∞–¥—Ä–æ–≤
          showOnlyLayers(avatar, { walk1On: true, walk2On: false, staticOn: false, tiredOn: false, signOn: false, hiOn: false });
          startWalkingAnimation(avatar);
          break;
        }
        case 'tired': {
          avatar.classList.add('tired');
          // –µ—Å–ª–∏ —É —Ç–µ–±—è –µ—Å—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Å–ª–æ–∏ —É—Å—Ç–∞–ª–æ—Å—Ç–∏, –æ—Ç–æ–±—Ä–∞–∑–∏–º –∏—Ö:
          if (avatar.querySelector('.layer.tired')) {
            showOnlyLayers(avatar, { tiredOn: true, staticOn: false, walk1On: false, walk2On: false, signOn: false, hiOn: false });
          } else {
            // fallback ‚Äî –ø—Ä–æ—Å—Ç–æ —Å—Ç–∞—Ç–∏–∫
            showOnlyLayers(avatar, { staticOn: true, walk1On: false, walk2On: false, tiredOn: false, signOn: false, hiOn: false });
          }
          // –£–±–∏—Ä–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏—è - –∞–≤–∞—Ç–∞—Ä –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å—Ç–∞—Ç–∏—á–Ω—ã–º
          if (avatar.dataset.tiredInterval) {
            clearInterval(parseInt(avatar.dataset.tiredInterval));
            avatar.dataset.tiredInterval = '';
            avatar.style.transform = '';
          }
          break;
        }
        case 'sign': {
          avatar.classList.add('sign');
          // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ª–æ–∏ sign
          if (avatar.querySelector('.layer.sign')) {
            showOnlyLayers(avatar, { signOn: true, staticOn: false, walk1On: false, walk2On: false, tiredOn: false, hiOn: false });
          } else {
            // fallback ‚Äî –ø—Ä–æ—Å—Ç–æ —Å—Ç–∞—Ç–∏–∫
            showOnlyLayers(avatar, { staticOn: true, walk1On: false, walk2On: false, tiredOn: false, signOn: false, hiOn: false });
          }
          break;
        }
        case 'hi': {
          avatar.classList.add('hi');
          // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ª–æ–∏ hi
          if (avatar.querySelector('.layer.hi')) {
            showOnlyLayers(avatar, { hiOn: true, staticOn: false, walk1On: false, walk2On: false, tiredOn: false, signOn: false });
          } else {
            // fallback ‚Äî –ø—Ä–æ—Å—Ç–æ —Å—Ç–∞—Ç–∏–∫
            showOnlyLayers(avatar, { staticOn: true, walk1On: false, walk2On: false, tiredOn: false, signOn: false, hiOn: false });
          }
          break;
        }
      }
    }

    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è–º–∏ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–∑–∏—Ü–∏–π
    function updateAvatarPosition(avatarContainer, nextX, nextY) {
      const prev = avatarContainer._prevPos || { x: nextX, y: nextY };
      const moving = (Math.abs(nextX - prev.x) + Math.abs(nextY - prev.y)) > 0.5;

      const avatar = avatarContainer.querySelector('.avatar');
      if (avatar) {
        if (moving && !avatar.classList.contains('walking')) {
          setAvatarState(avatar, 'walking');
        } else if (!moving && !avatar.classList.contains('static')) {
          setAvatarState(avatar, 'static');
        }
      }

      avatarContainer.style.transform = `translate(${nextX}px, ${nextY}px)`;
      avatarContainer._prevPos = { x: nextX, y: nextY };
    }

    // Race state
    let raceState = {
      isActive: false,
      participants: new Map(), // userId -> race avatar element
      positions: new Map(), // userId -> current position (0-100)
      speeds: new Map(), // userId -> current speed
      modifiers: new Map(), // userId -> speed modifier
      winner: null
    };

    // Load user avatar data
    async function loadUserAvatar(userId) {
      if (userAvatars.has(userId)) {
        return userAvatars.get(userId);
      }

      try {
        const response = await fetch(`/api/avatar/${userId}`);
        const data = await response.json();
        
        if (data.success) {
          const avatar = data.data;
          
          // Extract IDs from the full names
          const bodyId = avatar.body_skin ? avatar.body_skin.replace('body_skin_', '') : '1';
          const faceId = avatar.face_skin ? avatar.face_skin.replace('face_skin_', '') : '1';
          const clothesId = avatar.clothes_type ? avatar.clothes_type.replace('clothes_type_', '') : '1';
          const othersId = avatar.others_type ? avatar.others_type.replace('others_', '') : '1';
          
          const userAssets = {
            body: `/parts/body/${avatar.body_skin || 'body_skin_1'}.png`,
            face: `/parts/face/${avatar.face_skin || 'face_skin_1'}.png`,
            clothes: `/parts/clothes/${avatar.clothes_type || 'clothes_type_1'}.png`,
            others: `/parts/others/${avatar.others_type || 'others_1'}.png`,
            // Store the extracted IDs for use in other states
            bodyId: bodyId,
            faceId: faceId,
            clothesId: clothesId,
            othersId: othersId
          };
          
          userAvatars.set(userId, userAssets);
          return userAssets;
        }
      } catch (error) {
        console.error('Error loading user avatar:', error);
      }
      
      // Return default assets if loading failed
      userAvatars.set(userId, ASSETS);
      return ASSETS;
    }

    const stage = document.getElementById('stage');
    const active = new Map();
    const lastActivity = new Map(); // Track last message time per user

    function randomX() {
      const vw = Math.max(window.innerWidth, 320);
      const margin = 20; const width = 120;
      return Math.floor(Math.random() * Math.max(1, vw - width - margin*2)) + margin;
    }

    function createAvatar({ userId, displayName, color, avatarData }) {
      // Remove existing avatar if it exists (for updates)
      if (active.has(userId)) {
        const existingAvatar = active.get(userId);
        existingAvatar.remove();
        active.delete(userId);
      }

      const root = document.createElement('div');
      root.className = 'avatar';
      root.id = `avatar-${userId}`;
      root.style.left = randomX() + 'px';
      root.dataset.userId = userId;
      root.dataset.displayName = displayName || 'Guest';
      root.dataset.color = color || '#ffffff';

      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = displayName || 'Guest';
      root.appendChild(label);

      // Use saved avatar data or defaults
      const assets = {
        body: avatarData?.body || `/parts/body/${avatarData?.body_skin || 'body_skin_1'}.png`,
        face: avatarData?.face || `/parts/face/${avatarData?.face_skin || 'face_skin_1'}.png`,
        clothes: avatarData?.clothes || `/parts/clothes/${avatarData?.clothes_type || 'clothes_type_1'}.png`,
        others: avatarData?.others || `/parts/others/${avatarData?.others_type || 'others_1'}.png`
      };

      // Create walking animation layers using user's avatar data
      const walkAssets = {
        body: `/parts/body_walk_1/body_walk_1_skin_${avatarData?.bodyId || '1'}.png`,
        face: `/parts/face_walk_1/face_walk_1_skin_${avatarData?.faceId || '1'}.png`,
        clothes: `/parts/clothes_walk_1/clothes_walk_1_type_${avatarData?.clothesId || '1'}.png`,
        others: `/parts/others_walk_1/others_walk_1_type_${avatarData?.othersId || '1'}.png`
      };

      const walk2Assets = {
        body: `/parts/body_walk_2/body_walk_2_skin_${avatarData?.bodyId || '1'}.png`,
        face: `/parts/face_walk_2/face_walk_2_skin_${avatarData?.faceId || '1'}.png`,
        clothes: `/parts/clothes_walk_2/clothes_walk_2_type_${avatarData?.clothesId || '1'}.png`,
        others: `/parts/others_walk_2/others_walk_2_${avatarData?.othersId || '1'}.png`
      };

      // Create static layers (default pose)
      for (const key of ['body','clothes','face','others']) {
        const img = document.createElement('img');
        img.className = 'layer static';
        img.alt = key;
        img.src = assets[key];
        img.onload = () => console.log(`Loaded static layer: ${key} - ${assets[key]}`);
        img.onerror = () => console.log(`Failed to load static layer: ${key} - ${assets[key]}`);
        root.appendChild(img);
      }

      // Create walking animation layers (initially hidden)
      for (const key of ['body','clothes','face','others']) {
        const img = document.createElement('img');
        img.className = 'layer walk1';
        img.alt = `${key}_walk1`;
        img.src = walkAssets[key];
        img.style.opacity = '0';
        img.onload = () => console.log(`Loaded walk1 layer: ${key} - ${walkAssets[key]}`);
        img.onerror = () => console.log(`Failed to load walk1 layer: ${key} - ${walkAssets[key]}`);
        root.appendChild(img);
      }

      for (const key of ['body','clothes','face','others']) {
        const img = document.createElement('img');
        img.className = 'layer walk2';
        img.alt = `${key}_walk2`;
        img.src = walk2Assets[key];
        img.style.opacity = '0';
        root.appendChild(img);
      }

      // Create tired layers (initially hidden) using user's avatar data
      const tiredAssets = {
        body: `/parts/body_tired/body_tired_skin_${avatarData?.bodyId || '1'}.png`,
        face: `/parts/face_tired/face_tired_skin_${avatarData?.faceId || '1'}.png`,
        clothes: `/parts/clothes_tired/clothes_tired_type_${avatarData?.clothesId || '1'}.png`,
        others: `/parts/others_tired/others_tired_${avatarData?.othersId || '1'}_1.png`
      };

      for (const key of ['body','clothes','face','others']) {
        const img = document.createElement('img');
        img.className = 'layer tired';
        img.alt = `${key}_tired`;
        img.src = tiredAssets[key];
        img.style.opacity = '0';
        img.onload = () => console.log(`Loaded tired layer: ${key}`);
        img.onerror = () => console.log(`Failed to load tired layer: ${key} - ${tiredAssets[key]}`);
        root.appendChild(img);
      }

      // Create sign layers (initially hidden) using user's avatar data
      const signAssets = {
        body: `/parts/body_sign/body_sign_skin_${avatarData?.bodyId || '1'}.png`,
        face: `/parts/face_sign/face_sign_skin_${avatarData?.faceId || '1'}.png`,
        clothes: `/parts/clothes_sign/clothes_sign_type_${avatarData?.clothesId || '1'}.png`,
        others: `/parts/others_sign/others_sign_${avatarData?.othersId || '1'}.png`
      };

      for (const key of ['body','clothes','face','others']) {
        const img = document.createElement('img');
        img.className = 'layer sign';
        img.alt = `${key}_sign`;
        img.src = signAssets[key];
        img.style.opacity = '0';
        img.onload = () => console.log(`Loaded sign layer: ${key}`);
        img.onerror = () => console.log(`Failed to load sign layer: ${key} - ${signAssets[key]}`);
        root.appendChild(img);
      }

      // Create hi layers (initially hidden) using user's avatar data
      const hiAssets = {
        body: `/parts/body_hi/body_hi_skin_${avatarData?.bodyId || '1'}.png`,
        face: `/parts/face_hi/face_hi_skin_${avatarData?.faceId || '1'}.png`,
        clothes: `/parts/clothes_hi/clothes_hi_type_${avatarData?.clothesId || '1'}.png`,
        others: `/parts/others_hi/others_hi_${avatarData?.othersId || '1'}.png`
      };

      for (const key of ['body','clothes','face','others']) {
        const img = document.createElement('img');
        img.className = 'layer hi';
        img.alt = `${key}_hi`;
        img.src = hiAssets[key];
        img.style.opacity = '0';
        img.onload = () => console.log(`Loaded hi layer: ${key}`);
        img.onerror = () => console.log(`Failed to load hi layer: ${key} - ${hiAssets[key]}`);
        root.appendChild(img);
      }

      // Create emoji element
      const emojiEl = document.createElement('div');
      emojiEl.className = 'emoji';
      emojiEl.style.display = 'none';
      root.appendChild(emojiEl);

      stage.appendChild(root);
      active.set(userId, root);
      lastActivity.set(userId, Date.now());

      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ static
      setAvatarState(root, 'static');

      // Debug: check if others layer exists
      setTimeout(() => {
        const othersLayer = root.querySelector('.layer[alt="others"]');
        console.log('Others layer found:', othersLayer);
        console.log('Others layer src:', othersLayer?.src);
        console.log('Others layer opacity:', othersLayer?.style.opacity);
        console.log('Root classes:', root.className);
      }, 1000);

      // Server will handle timing via events
    }

    function removeAvatar(userId) {
      const el = active.get(userId);
      if (!el) return;
      
      // Clear all timeouts and intervals using new system
      stopAvatarIntervals(el);
      if (el.animationTimeout) clearTimeout(el.animationTimeout);
      if (el.tiredTimeout) clearTimeout(el.tiredTimeout);
      if (el.despawnTimeout) clearTimeout(el.despawnTimeout);
      if (el.signTimeout) clearTimeout(el.signTimeout);
      if (el.hiTimeout) clearTimeout(el.hiTimeout);
      if (el.laughTimeout) clearTimeout(el.laughTimeout);
      if (el.activityInterval) clearInterval(el.activityInterval);
      
      el.style.transition = 'transform .4s ease, opacity .4s ease';
      el.style.opacity = '0';
      el.style.transform += ' translateY(20px)';
      setTimeout(() => {
        el.remove();
        active.delete(userId);
        lastActivity.delete(userId);
      }, 450);
    }

    function showEmoji(userId, emoji) {
      const el = active.get(userId);
      if (!el) return;
      
      // Update activity time
      lastActivity.set(userId, Date.now());
      
      // Clear any existing timeouts
      if (el.animationTimeout) {
        clearTimeout(el.animationTimeout);
      }
      if (el.tiredTimeout) {
        clearTimeout(el.tiredTimeout);
      }
      if (el.despawnTimeout) {
        clearTimeout(el.despawnTimeout);
      }
      if (el.signTimeout) {
        clearTimeout(el.signTimeout);
      }
      if (el.hiTimeout) {
        clearTimeout(el.hiTimeout);
      }
      if (el.laughTimeout) {
        clearTimeout(el.laughTimeout);
      }
      
      // Clear any activity monitoring intervals
      if (el.activityInterval) {
        clearInterval(el.activityInterval);
      }
      
      // Remove other states
      el.classList.remove('tired', 'walking', 'left', 'hi');
      
      // Show sign state with emoji
      el.classList.add('sign');
      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º sign —Å–æ—Å—Ç–æ—è–Ω–∏–µ
      setAvatarState(el, 'sign');
      const emojiEl = el.querySelector('.emoji');
      if (emojiEl) {
        // Clear previous content
        emojiEl.innerHTML = '';
        
        // Check if it's a URL (Twitch emote image)
        if (emoji.startsWith('http')) {
          // Twitch emote - create image with load handling
          const img = document.createElement('img');
          img.src = emoji;
          img.alt = 'emote';
          img.style.height = '100%';
          img.style.display = 'none'; // Hide until loaded
          
          img.onload = () => {
            img.style.display = 'block';
            emojiEl.style.display = 'block';
          };
          
          img.onerror = () => {
            // Fallback to text if image fails to load
            emojiEl.textContent = 'üòÄ';
            emojiEl.style.display = 'block';
          };
          
          emojiEl.innerHTML = '';
          emojiEl.appendChild(img);
        } else {
          // Unicode emoji - show as text
          emojiEl.textContent = emoji;
          emojiEl.style.display = 'block';
        }
      }
      
      // Lock movement during emoji display
      el.dataset.locked = '1';
      clearTimeout(el.lockTimer);
      el.lockTimer = setTimeout(() => { 
        el.dataset.locked = ''; 
      }, 3200);
      
      console.log(`Showing emoji "${emoji}" for user ${userId}`);
      console.log('Emoji element:', emojiEl);
      console.log('Emoji text content:', emojiEl?.textContent);
      
      // Hide sign state after 3 seconds
      el.signTimeout = setTimeout(() => {
        el.classList.remove('sign');
        if (emojiEl) {
          emojiEl.style.display = 'none';
        }
        
        // Return to base state
        setAvatarState(el, 'static');
        
        // Server will handle tired state via events
      }, 3000);
    }

    function showHi(userId) {
      console.log(`[overlay] showHi called for userId: ${userId}`);
      const el = active.get(userId);
      if (!el) {
        console.log(`[overlay] showHi: no avatar found for userId: ${userId}`);
        return;
      }
      console.log(`[overlay] showHi: avatar found, proceeding with hi animation`);
      
      // Update activity time
      lastActivity.set(userId, Date.now());
      
      // Clear any existing timeouts
      if (el.animationTimeout) {
        clearTimeout(el.animationTimeout);
      }
      if (el.tiredTimeout) {
        clearTimeout(el.tiredTimeout);
      }
      if (el.despawnTimeout) {
        clearTimeout(el.despawnTimeout);
      }
      if (el.signTimeout) {
        clearTimeout(el.signTimeout);
      }
      if (el.hiTimeout) {
        clearTimeout(el.hiTimeout);
      }
      if (el.laughTimeout) {
        clearTimeout(el.laughTimeout);
      }
      
      // Clear any activity monitoring intervals
      if (el.activityInterval) {
        clearInterval(el.activityInterval);
      }
      
      // Remove other states
      el.classList.remove('tired', 'walking', 'left', 'sign', 'laughing');
      
      // Show hi state
      el.classList.add('hi');
      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º hi —Å–æ—Å—Ç–æ—è–Ω–∏–µ
      setAvatarState(el, 'hi');
      
      // Lock movement during hi display
      el.dataset.locked = '1';
      clearTimeout(el.lockTimer);
      el.lockTimer = setTimeout(() => { 
        el.dataset.locked = ''; 
      }, 5200);
      
      console.log(`Showing hi state for user ${userId}`);
      
      // Hide hi state after 5 seconds
      el.hiTimeout = setTimeout(() => {
        el.classList.remove('hi');
        
        // Return to base state
        setAvatarState(el, 'static');
        
        // Server will handle tired state via events
      }, 5000);
    }

    function showLaugh(userId) {
      console.log(`[overlay] showLaugh called for userId: ${userId}`);
      const el = active.get(userId);
      if (!el) {
        console.log(`[overlay] showLaugh: no avatar found for userId: ${userId}`);
        return;
      }
      console.log(`[overlay] showLaugh: avatar found, proceeding with laugh animation`);
      
      // Update activity time
      lastActivity.set(userId, Date.now());
      
      // Clear any existing timeouts
      if (el.animationTimeout) {
        clearTimeout(el.animationTimeout);
      }
      if (el.tiredTimeout) {
        clearTimeout(el.tiredTimeout);
      }
      if (el.despawnTimeout) {
        clearTimeout(el.despawnTimeout);
      }
      if (el.signTimeout) {
        clearTimeout(el.signTimeout);
      }
      if (el.hiTimeout) {
        clearTimeout(el.hiTimeout);
      }
      if (el.laughTimeout) {
        clearTimeout(el.laughTimeout);
      }
      
      // Clear any activity monitoring intervals
      if (el.activityInterval) {
        clearInterval(el.activityInterval);
      }
      
      // Remove other states
      el.classList.remove('tired', 'walking', 'left', 'sign', 'hi');
      
      // Show laugh animation
      el.classList.add('laughing');
      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º static —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è laughing
      setAvatarState(el, 'static');
      
      // Lock movement during laugh animation
      el.dataset.locked = '1';
      clearTimeout(el.lockTimer);
      el.lockTimer = setTimeout(() => { 
        el.dataset.locked = ''; 
      }, 2000);
      
      console.log(`Showing laugh animation for user ${userId}`);
      
      // Remove laugh class after animation completes
      el.laughTimeout = setTimeout(() => {
        el.classList.remove('laughing');
        
        // Return to base state
        setAvatarState(el, 'static');
        
        // Server will handle tired state via events
      }, 1500);
    }

    function showQuestion(userId) {
      console.log(`[overlay] showQuestion called for userId: ${userId}`);
      const el = active.get(userId);
      if (!el) {
        console.log(`[overlay] showQuestion: no avatar found for userId: ${userId}`);
        return;
      }
      console.log(`[overlay] showQuestion: avatar found, proceeding with question animation`);
      
      // Update activity time
      lastActivity.set(userId, Date.now());
      
      // Clear any existing timeouts
      if (el.animationTimeout) {
        clearTimeout(el.animationTimeout);
      }
      if (el.tiredTimeout) {
        clearTimeout(el.tiredTimeout);
      }
      if (el.despawnTimeout) {
        clearTimeout(el.despawnTimeout);
      }
      if (el.signTimeout) {
        clearTimeout(el.signTimeout);
      }
      if (el.hiTimeout) {
        clearTimeout(el.hiTimeout);
      }
      if (el.laughTimeout) {
        clearTimeout(el.laughTimeout);
      }
      if (el.questionTimeout) {
        clearTimeout(el.questionTimeout);
      }
      
      // Clear any activity monitoring intervals
      if (el.activityInterval) {
        clearInterval(el.activityInterval);
      }
      
      // Remove other states
      el.classList.remove('tired', 'walking', 'left', 'sign', 'hi', 'laughing');
      
      // Create question mark element
      const questionEl = el.querySelector('.question-mark');
      if (!questionEl) {
        const newQuestionEl = document.createElement('div');
        newQuestionEl.className = 'question-mark';
        newQuestionEl.textContent = '?';
        el.appendChild(newQuestionEl);
      } else {
        questionEl.style.display = 'block';
      }
      
      // Lock movement during question display
      el.dataset.locked = '1';
      clearTimeout(el.lockTimer);
      el.lockTimer = setTimeout(() => { 
        el.dataset.locked = ''; 
      }, 4000);
      
      console.log(`Showing question mark for user ${userId}`);
      
      // Hide question mark after 4 seconds
      el.questionTimeout = setTimeout(() => {
        const questionEl = el.querySelector('.question-mark');
        if (questionEl) {
          questionEl.style.display = 'none';
        }
        
        // Server will handle tired state via events
      }, 4000);
    }

    function showGift(userId, giftData) {
      const el = active.get(userId);
      if (!el) return;
      
      // Update activity time
      lastActivity.set(userId, Date.now());
      
      // Create gift element
      const giftEl = document.createElement('div');
      giftEl.className = 'gift';
      
      const img = document.createElement('img');
      img.src = giftData.path;
      img.alt = `${giftData.type} gift ${giftData.id}`;
      giftEl.appendChild(img);
      
      el.appendChild(giftEl);
      
      // Remove gift element after animation
      setTimeout(() => {
        if (giftEl.parentNode) {
          giftEl.parentNode.removeChild(giftEl);
        }
      }, 2000);
      
      console.log(`Showing gift ${giftData.type}_${giftData.id} for user ${userId}`);
    }

    function moveAvatar(userId, messageCount) {
      const el = active.get(userId);
      if (!el) return;
      
      // Debug: Log the received messageCount
      console.log(`[moveAvatar] User: ${userId}, MessageCount: ${messageCount}, Type: ${typeof messageCount}`);
      
      // Check if movement is locked (during emoji display)
      if (el.dataset.locked === '1') return;
      
      // Update activity time
      lastActivity.set(userId, Date.now());
      
      // Clear any existing timeouts and intervals
      if (el.animationTimeout) {
        clearTimeout(el.animationTimeout);
      }
      if (el.tiredTimeout) {
        clearTimeout(el.tiredTimeout);
      }
      if (el.despawnTimeout) {
        clearTimeout(el.despawnTimeout);
      }
      if (el.signTimeout) {
        clearTimeout(el.signTimeout);
      }
      if (el.activityInterval) {
        clearInterval(el.activityInterval);
      }
      if (el.movementInterval) {
        clearInterval(el.movementInterval);
      }
      
      // Remove other states
      el.classList.remove('tired', 'sign');
      
      // Start walking animation using new system immediately (if not already walking)
      if (!el.classList.contains('walking')) {
        setAvatarState(el, 'walking');
      }
      
      // Ensure messageCount is a number and has a minimum value
      const numMessageCount = parseInt(messageCount) || 1;
      console.log(`[moveAvatar] Parsed messageCount: ${numMessageCount}`);
      
      // Calculate distance based on message count (more messages = longer distance)
      const baseDistance = 10; // Base distance per message (reasonable movement)
      const totalDistance = numMessageCount * baseDistance;
      
      console.log(`[moveAvatar] Total distance: ${totalDistance}px`);
      
      // Determine direction randomly (50/50 chance)
      const direction = Math.random() < 0.5 ? 1 : -1;
      const targetDistance = totalDistance * direction;
      
      console.log(`[moveAvatar] Direction: ${direction}, Target distance: ${targetDistance}px`);
      
      // Set direction class
      if (direction < 0) {
        el.classList.add('left');
      } else {
        el.classList.remove('left');
      }
      
      // Start smooth movement with constant speed
      startSmoothMovement(el, targetDistance);
    }
    
    function startSmoothMovement(el, targetDistance) {
      const currentLeft = parseInt(el.style.left) || 0;
      const originalDirection = targetDistance > 0 ? 1 : -1;
      
      console.log(`[startSmoothMovement] Current position: ${currentLeft}px, Target distance: ${targetDistance}px, Direction: ${originalDirection}`);
      
      // Define screen boundaries
      const minX = 0;
      const maxX = window.innerWidth - 140; // avatar width
      
      // Start movement with bounce logic
      startMovementWithBounce(el, currentLeft, targetDistance, originalDirection, minX, maxX);
    }
    
    function startMovementWithBounce(el, startPosition, remainingDistance, direction, minX, maxX) {
      const speed = 100; // pixels per second (constant speed)
      let lastTime = Date.now();
      let currentPosition = startPosition;
      let currentDirection = direction;
      let totalRemainingDistance = Math.abs(remainingDistance);
      
      console.log(`[startMovementWithBounce] Starting movement: position=${currentPosition}, remaining=${totalRemainingDistance}px, direction=${currentDirection}`);
      
      el.movementInterval = setInterval(() => {
        const currentTime = Date.now();
        const deltaTime = currentTime - lastTime; // time since last frame
        const frameDistance = (speed * deltaTime) / 1000; // distance moved in this frame
        
        // Calculate new position
        const newPosition = currentPosition + (frameDistance * currentDirection);
        
        // Check for boundary collision
        if (newPosition <= minX) {
          // Hit left boundary - bounce right
          const distanceToBoundary = currentPosition - minX;
          const remainingAfterBounce = totalRemainingDistance - distanceToBoundary;
          
          if (remainingAfterBounce > 0) {
            currentPosition = minX;
            currentDirection = 1; // reverse direction
            totalRemainingDistance = remainingAfterBounce;
            el.classList.remove('left'); // face right
            
            console.log(`[startMovementWithBounce] Hit left boundary, bouncing right. Remaining: ${totalRemainingDistance}px`);
          } else {
            // Movement complete
            currentPosition = minX;
            el.style.left = currentPosition + 'px';
            finishMovement(el);
            return;
          }
        } else if (newPosition >= maxX) {
          // Hit right boundary - bounce left
          const distanceToBoundary = maxX - currentPosition;
          const remainingAfterBounce = totalRemainingDistance - distanceToBoundary;
          
          if (remainingAfterBounce > 0) {
            currentPosition = maxX;
            currentDirection = -1; // reverse direction
            totalRemainingDistance = remainingAfterBounce;
            el.classList.add('left'); // face left
            
            console.log(`[startMovementWithBounce] Hit right boundary, bouncing left. Remaining: ${totalRemainingDistance}px`);
          } else {
            // Movement complete
            currentPosition = maxX;
            el.style.left = currentPosition + 'px';
            finishMovement(el);
            return;
          }
        } else {
          // Normal movement - check if we've moved the full remaining distance
          const distanceMoved = Math.abs(newPosition - startPosition);
          if (distanceMoved >= totalRemainingDistance) {
            // Movement complete
            currentPosition = startPosition + (totalRemainingDistance * currentDirection);
            el.style.left = currentPosition + 'px';
            finishMovement(el);
            return;
          } else {
            currentPosition = newPosition;
          }
        }
        
        // Update avatar position
        el.style.left = currentPosition + 'px';
        
        // Update time for next iteration
        lastTime = currentTime;
        
      }, 16); // ~60fps for smooth animation
    }
    
    function finishMovement(el) {
      clearInterval(el.movementInterval);
      el.movementInterval = null;
      
      // Stop walking animation immediately when movement completes
      setAvatarState(el, 'static');
      el.classList.remove('left');
      
      console.log(`[finishMovement] Movement completed for avatar`);
    }

    // Function to stop walking animation when movement ends
    function stopWalkingAnimation(userId) {
      const el = active.get(userId);
      if (!el) return;
      
      // Clear any existing animation timeout
      if (el.animationTimeout) {
        clearTimeout(el.animationTimeout);
        el.animationTimeout = null;
      }
      
      // Clear movement interval if running
      if (el.movementInterval) {
        clearInterval(el.movementInterval);
        el.movementInterval = null;
      }
      
      // Stop walking animation and return to static state
      setAvatarState(el, 'static');
      el.classList.remove('left');
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ —É—Å—Ç–∞–ª–æ—Å—Ç–∏
    function startTiredAnimation(avatar) {
      // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â—É—é –∞–Ω–∏–º–∞—Ü–∏—é —É—Å—Ç–∞–ª–æ—Å—Ç–∏ –µ—Å–ª–∏ –µ—Å—Ç—å
      if (avatar.dataset.tiredInterval) {
        clearInterval(parseInt(avatar.dataset.tiredInterval));
      }
      
      // –ü—Ä–æ—Å—Ç–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏—è –¥–ª—è —É—Å—Ç–∞–ª–æ–≥–æ –∞–≤–∞—Ç–∞—Ä–∞
      let isLeft = false;
      const interval = setInterval(() => {
        if (avatar.classList.contains('tired')) {
          // –ü–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤–ª–µ–≤–æ-–≤–ø—Ä–∞–≤–æ
          avatar.style.transform = `translateX(${isLeft ? '-2px' : '2px'})`;
          isLeft = !isLeft;
        } else {
          // –ï—Å–ª–∏ –∞–≤–∞—Ç–∞—Ä –±–æ–ª—å—à–µ –Ω–µ tired, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
          clearInterval(interval);
          avatar.style.transform = '';
        }
      }, 1000); // –ö–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É
      
      avatar.dataset.tiredInterval = String(interval);
    }

    // Race functions
    function startRace(data) {
      console.log('Starting race with data:', data);
      raceState.isActive = true;
      raceState.participants.clear();
      raceState.positions.clear();
      raceState.speeds.clear();
      raceState.modifiers.clear();
      raceState.winner = null;

      // Remove all existing avatars from screen
      const existingAvatars = document.querySelectorAll('.avatar');
      existingAvatars.forEach(avatar => {
        // –û—á–∏—â–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º
        stopAvatarIntervals(avatar);
        avatar.remove();
      });
      // –û—á–∏—â–∞–µ–º Map –∞–∫—Ç–∏–≤–Ω—ã—Ö –∞–≤–∞—Ç–∞—Ä–æ–≤
      active.clear();
      lastActivity.clear();
      console.log('Removed all existing avatars');

      // Show race track
      document.getElementById('raceTrack').style.display = 'block';
      console.log('Race track displayed');

      // Create race avatars for participants
      const createAvatars = async () => {
        for (let index = 0; index < data.participants.length; index++) {
          const userId = data.participants[index];
          const userAssets = await loadUserAvatar(userId);
          const raceAvatar = createRaceAvatar(userId, userAssets, index);
          raceState.participants.set(userId, raceAvatar);
          raceState.positions.set(userId, 0);
          raceState.speeds.set(userId, 0.25); // Base speed (—É–º–µ–Ω—å—à–µ–Ω–æ –≤ 4 —Ä–∞–∑–∞)
          raceState.modifiers.set(userId, 0);
        }
      };
      
      createAvatars();

      // Start countdown
      startRaceCountdown(data.countdown);
    }

    function createRaceAvatar(userId, userAssets, index) {
      const raceContainer = document.createElement('div');
      raceContainer.className = 'race-avatar';
      raceContainer.style.top = `calc(50% + ${index * 60 - (raceState.participants.size - 1) * 30}px)`;

      const avatar = document.createElement('div');
      avatar.className = 'avatar';
      avatar.dataset.userId = userId;

      // --- static ---
      const baseLayers = ['body', 'face', 'clothes', 'others'];
      baseLayers.forEach(layer => {
        const img = document.createElement('img');
        img.className = 'layer static';
        img.alt = layer;
        img.src = userAssets[layer]; // /parts/* –∏–∑ loadUserAvatar
        avatar.appendChild(img);
      });

      // –ü–æ–¥–≥–æ—Ç–æ–≤–∏–º ID —Å–ª–æ—ë–≤ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–π (–æ–Ω–∏ —É–∂–µ –ø—Ä–∏—Ö–æ–¥—è—Ç –∏–∑ loadUserAvatar)
      const bodyId    = userAssets.bodyId    || '1';
      const faceId    = userAssets.faceId    || '1';
      const clothesId = userAssets.clothesId || '1';
      const othersId  = userAssets.othersId  || '1';

      // --- walk1 ---
      const walk1Src = {
        body:    `/parts/body_walk_1/body_walk_1_skin_${bodyId}.png`,
        face:    `/parts/face_walk_1/face_walk_1_skin_${faceId}.png`,
        clothes: `/parts/clothes_walk_1/clothes_walk_1_type_${clothesId}.png`,
        others:  `/parts/others_walk_1/others_walk_1_type_${othersId}.png`,
      };
      baseLayers.forEach(layer => {
        const img = document.createElement('img');
        img.className = 'layer walk1';
        img.alt = `${layer}_walk1`;
        img.src = walk1Src[layer];
        avatar.appendChild(img);
      });

      // --- walk2 ---
      const walk2Src = {
        body:    `/parts/body_walk_2/body_walk_2_skin_${bodyId}.png`,
        face:    `/parts/face_walk_2/face_walk_2_skin_${faceId}.png`,
        clothes: `/parts/clothes_walk_2/clothes_walk_2_type_${clothesId}.png`,
        others:  `/parts/others_walk_2/others_walk_2_${othersId}.png`,
      };
      baseLayers.forEach(layer => {
        const img = document.createElement('img');
        img.className = 'layer walk2';
        img.alt = `${layer}_walk2`;
        img.src = walk2Src[layer];
        avatar.appendChild(img);
      });

      // --- tired ---
      const tiredSrc = {
        body:    `/parts/body_tired/body_tired_skin_${bodyId}.png`,
        face:    `/parts/face_tired/face_tired_skin_${faceId}.png`,
        clothes: `/parts/clothes_tired/clothes_tired_type_${clothesId}.png`,
        others:  `/parts/others_tired/others_tired_${othersId}_1.png`,
      };
      baseLayers.forEach(layer => {
        const img = document.createElement('img');
        img.className = 'layer tired';
        img.alt = `${layer}_tired`;
        img.src = tiredSrc[layer];
        avatar.appendChild(img);
      });

      raceContainer.appendChild(avatar);
      document.body.appendChild(raceContainer);
      
      // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ static –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏
      setAvatarState(avatar, 'static');
      
      return raceContainer;
    }

    function startRaceWalkingAnimation(avatar) {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏–π
      setAvatarState(avatar, 'walking');
    }

    function startRaceCountdown(count) {
      const countdownEl = document.getElementById('raceCountdown');
      countdownEl.style.display = 'block';
      
      let current = count;
      const interval = setInterval(() => {
        if (current > 0) {
          countdownEl.textContent = current;
          current--;
        } else {
          clearInterval(interval);
          countdownEl.style.display = 'none';
          // Wait a bit for avatars to be created
          setTimeout(() => {
            startRaceMovement();
          }, 1000);
        }
      }, 1000);
    }

    function startRaceMovement() {
      // Change avatars to walking state when race starts
      raceState.participants.forEach((avatarEl, userId) => {
        const avatar = avatarEl.querySelector('.avatar');
        if (avatar) {
          // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏–π
          setAvatarState(avatar, 'walking');
        }
      });
      
      const raceInterval = setInterval(() => {
        if (!raceState.isActive) {
          clearInterval(raceInterval);
          return;
        }

        if (raceState.participants.size === 0) {
          return;
        }

        raceState.participants.forEach((avatarEl, userId) => {
          const currentPos = raceState.positions.get(userId) || 0;
          const baseSpeed = raceState.speeds.get(userId) || 1;
          const modifier = raceState.modifiers.get(userId) || 0;
          const totalSpeed = baseSpeed + modifier;
          
          const newPos = Math.min(currentPos + totalSpeed, 100);
          raceState.positions.set(userId, newPos);
          
          // Update position
          const trackWidth = window.innerWidth - 40; // Account for margins
          const leftPos = (newPos / 100) * trackWidth;
          avatarEl.style.left = `${leftPos}px`;
          
          // Check for winner
          if (newPos >= 100 && !raceState.winner) {
            raceState.winner = userId;
            // Move winner to center for trophy display
            avatarEl.style.left = '50%';
            avatarEl.style.transform = 'translateX(-50%)';
            
            // Emit race finish event to server
            fetch('/api/race/finish', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(withStreamerAuth({ winnerId: userId }))
            }).catch(err => console.error('Error finishing race:', err));
            
            finishRace(userId);
            clearInterval(raceInterval);
          }
        });
      }, 50); // 20 FPS
    }

    function updateRaceSpeed(userId, modifier) {
      if (raceState.modifiers.has(userId)) {
        const currentModifier = raceState.modifiers.get(userId);
        raceState.modifiers.set(userId, currentModifier + modifier);
      }
    }

    function finishRace(winnerId) {
      raceState.isActive = false;
      
      // Move winner to center and change to static state
      const winnerAvatar = raceState.participants.get(winnerId);
      if (winnerAvatar) {
        const avatar = winnerAvatar.querySelector('.avatar');
        if (avatar) {
          // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏–π
          setAvatarState(avatar, 'static');
        }
        winnerAvatar.style.left = '50%';
        winnerAvatar.style.transform = 'translateX(-50%)';
      }
      
      // Show winner
      const winnerEl = document.getElementById('raceWinner');
      winnerEl.textContent = 'üèÜ –ü–û–ë–ï–î–ò–¢–ï–õ–¨!';
      winnerEl.style.display = 'block';
      
      // Hide after 5 seconds
      setTimeout(() => {
        winnerEl.style.display = 'none';
        document.getElementById('raceTrack').style.display = 'none';
        
        // Remove race avatars and clean up animations
        raceState.participants.forEach(avatarEl => {
          // Clear all intervals using new system
          const avatar = avatarEl.querySelector('.avatar');
          if (avatar) {
            stopAvatarIntervals(avatar);
          }
          avatarEl.remove();
        });
        
        // Clear race state completely
        raceState.participants.clear();
        raceState.positions.clear();
        raceState.speeds.clear();
        raceState.modifiers.clear();
        raceState.winner = null;
        raceState.isActive = false;
      }, 5000);
    }

    // Food Game State
    const foodGameState = {
      isActive: false,
      participants: new Map(), // userId -> avatar element
      scores: new Map(), // userId -> score
      directions: new Map(), // userId -> direction (1 = right, -1 = left)
      carrots: new Map(), // carrotId -> carrot element
      speedModifiers: new Map(), // userId -> speed modifier
      displayNames: new Map(), // userId -> display name
      winner: null,
      gameOver: false
    };

    /* === –ì–ª–æ–±–∞–ª—å–Ω—ã–µ === */
    const STATE = {
      started: false,
      finished: false,
      players: new Map(), // id -> {el, lane, out}
    };
    const LANES = [0, 1, 2]; // 0=–≤–µ—Ä—Ö, 1=—Ü–µ–Ω—Ç—Ä, 2=–Ω–∏–∑
    
    // –°–ª–æ–≤–∞—Ä—å DOM-—ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
    const OBST = new Map(); // id -> { el, lane, x, serverX }
    const SERVER_OBSTACLE_SYNC = true;

    /* === –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è: –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ –ø–æ–ª–æ—Å–∞–º === */
    function laneCenterY(laneIndex) {
      // trackEl ‚Äî –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Ç—Ä–∞—Å—Å—ã
      const trackEl = document.getElementById('racePlanArea');
      if (!trackEl) {
        console.error('laneCenterY: racePlanArea not found');
        return 0;
      }
      
      const trackRect = trackEl.getBoundingClientRect();
      console.log('laneCenterY: trackRect dimensions', trackRect.width, trackRect.height);

      // –ü–æ–ª–æ—Å 3? –¢–æ–≥–¥–∞ –¥–µ–ª–∏–º –≤—ã—Å–æ—Ç—É –Ω–∞ 3 —Ä–∞–≤–Ω—ã—Ö –∫–æ—Ä–∏–¥–æ—Ä–∞:
      const lanes = 3;
      const laneH = trackRect.height / lanes;

      // –¶–µ–Ω—Ç—Ä laneIndex (0..lanes-1) –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö track
      const center = (laneIndex + 0.5) * laneH;
      
      console.log('laneCenterY: lane', laneIndex, 'center', center, 'laneH', laneH);

      // –£—á—Ç—ë–º –≤—ã—Å–æ—Ç—É –∞–≤–∞—Ç–∞—Ä–∞ —Å –º–∞—Å—à—Ç–∞–±–æ–º ‚Äî —á—Ç–æ–±—ã ¬´—Ü–µ–Ω—Ç—Ä¬ª –ø—Ä–∏—Ö–æ–¥–∏–ª—Å—è —Ä–µ–∞–ª—å–Ω–æ –ø–æ —Ü–µ–Ω—Ç—Ä—É
      // –ë–µ—Ä—ë–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —É–∑–µ–ª –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞
      return Math.round(center);
    }

    function measureAvatar(el) {
      // —à–∏—Ä–∏–Ω–∞/–≤—ã—Å–æ—Ç–∞ –≤–Ω–µ—à–Ω–µ–≥–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ —Å —É—á—ë—Ç–æ–º —Å–∫–µ–π–ª–∞ –≤–Ω—É—Ç—Ä–∏
      const w = el.clientWidth || 128;
      const h = el.clientHeight || 128;
      return {w, h};
    }

    async function ensureAvatarReady(el) {
      // –¥–æ–∂–¥—ë–º—Å—è –∑–∞–≥—Ä—É–∑–∫–∏ –≤—Å–µ—Ö <img> –≤–Ω—É—Ç—Ä–∏
      const imgs = Array.from(el.querySelectorAll('img'));
      await Promise.all(imgs.map(img => img.complete ? Promise.resolve() : new Promise(r => {
        img.addEventListener('load', r, { once: true });
        img.addEventListener('error', r, { once: true });
      })));
    }

    function preparePlayersBeforeCountdown() {
      console.log('preparePlayersBeforeCountdown: starting with', racePlanState.participants.size, 'participants');
      
      racePlanState.participants.forEach((el, userId) => {
        console.log('preparePlayersBeforeCountdown: processing participant', userId);
        
        if (!STATE.players.has(userId)) {
          const lane = racePlanState.levels.get(userId) ?? 1; // 0..2
          STATE.players.set(userId, {
            el,
            lane,
            x: 50,        // —Å—Ç–∞—Ä—Ç–æ–≤—ã–π X (–Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã–π)
            serverX: 50,  // —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å –±—ç–∫–æ–º
            out: false,
            lives: 3
          });
          
          // –°—Ä–∞–∑—É –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∞–≤–∞—Ç–∞—Ä –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –¥–æ—Ä–æ–∂–∫–µ
          const { w, h } = measureAvatar(el);
          const trackEl = document.querySelector('#racePlanArea');
          const trackRect = trackEl ? trackEl.getBoundingClientRect() : { width: 800, height: 360 };
          
          const rawX = 50 - Math.round(w / 2);
          const x = Math.max(0, Math.min(rawX, trackRect.width - w));
          const rawY = laneCenterY(lane) - h / 2;
          const y = Math.max(0, Math.min(rawY, trackRect.height - h));
          
          el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
          console.log('preparePlayersBeforeCountdown: created new player for', userId, 'lane', lane);
        } else {
          // –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å, —Ö–æ—Ç—è –±—ã lane –æ–±–Ω–æ–≤–∏–º –Ω–∞ –∞–∫—Ç—É–∞–ª—å–Ω—ã–π
          const p = STATE.players.get(userId);
          p.lane = racePlanState.levels.get(userId) ?? p.lane ?? 1;
          console.log('preparePlayersBeforeCountdown: updated existing player for', userId, 'lane', p.lane);
        }
      });
      
      console.log('preparePlayersBeforeCountdown: completed with', STATE.players.size, 'players');
    }

    async function placePlayersAtLanesBeforeStart() {
      console.log('placePlayersAtLanesBeforeStart: starting with', STATE.players.size, 'players');
      
      // –±–µ–∑ –ø–ª–∞–≤–Ω–æ—Å—Ç–∏ ‚Äî —Å—Ä–∞–∑—É –≤ –Ω—É–∂–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã, —á—Ç–æ–±—ã –Ω–µ ¬´–ø—Ä—ã–≥–∞–ª–æ¬ª –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
      for (const [userId, p] of STATE.players) {
        const el = p.el;
        if (!el) {
          console.log('placePlayersAtLanesBeforeStart: no element for user', userId);
          continue;
        }

        console.log('placePlayersAtLanesBeforeStart: processing user', userId, 'lane', p.lane);
        
        await ensureAvatarReady(el);
        const { w, h } = measureAvatar(el);
        console.log('placePlayersAtLanesBeforeStart: measured dimensions', w, h);

        const yCenter = laneCenterY(p.lane);
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ —Ñ–æ—Ä–º—É–ª—É —á—Ç–æ –∏ –¥–ª—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
        const rawY = yCenter - h / 2;
        
        // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
        const trackEl = document.querySelector('#racePlanArea');
        const trackRect = trackEl ? trackEl.getBoundingClientRect() : { width: 800, height: 360 };
        
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        const rawX = (p.x ?? 50) - Math.round(w / 2);
        const x = Math.max(0, Math.min(rawX, trackRect.width - w));
        const y = Math.max(0, Math.min(rawY, trackRect.height - h));
        
        console.log('placePlayersAtLanesBeforeStart: positioning at', x, y, 'center', yCenter);

        // –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–∏–º transition —É –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        const prevTransition = el.style.transition;
        el.style.transition = 'none';
        el.style.transform = `translate3d(${x}px, ${y}px, 0)`;

        // —Å–ª–µ–¥—É—é—â–∏–π –∫–∞–¥—Ä ‚Äî –≤–µ—Ä–Ω—ë–º transition (–µ—Å–ª–∏ –æ–Ω –Ω—É–∂–µ–Ω)
        requestAnimationFrame(() => {
          el.style.transition = prevTransition || '';
        });
      }
      
      console.log('placePlayersAtLanesBeforeStart: completed');
    }

    function getLaneBounds(laneIndex) {
      const track = document.querySelector('#racePlanArea');
      const h = track.clientHeight;
      const laneHeight = h / 3;
      return {
        top: laneIndex * laneHeight,
        bottom: (laneIndex + 1) * laneHeight,
        center: (laneIndex * laneHeight) + laneHeight / 2
      };
    }

    function updateRacePlanAvatarPosition(playerId, laneIndex) {
      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
      racePlanState.levels.set(playerId, laneIndex);
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
      const p = STATE.players.get(playerId);
      if (p) {
        p.lane = Math.max(0, Math.min(2, laneIndex)); // –∫–ª–∏–º–ø
        const { w, h } = measureAvatar(p.el);
        
        // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
        const trackEl = document.querySelector('#racePlanArea');
        const trackRect = trackEl ? trackEl.getBoundingClientRect() : { width: 800, height: 360 };
        
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        const rawX = (p.x ?? 50) - Math.round(w / 2);
        const x = Math.max(0, Math.min(rawX, trackRect.width - w));
        
        const rawY = laneCenterY(p.lane) - Math.round(h / 2);
        const y = Math.max(0, Math.min(rawY, trackRect.height - h));
        
        p.el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
      }
      
      // –¢–∞–∫–∂–µ –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
      const avatarEl = racePlanState.participants.get(playerId);
      if (avatarEl) {
        const { w, h } = measureAvatar(avatarEl);
        const x = (p?.x ?? 50) - Math.round(w / 2);
        const y = laneCenterY(laneIndex) - Math.round(h / 2);
        avatarEl.style.transform = `translate3d(${x}px, ${y}px, 0)`;
      }
    }
    
    function smoothLevelTransition(playerId, newLevel) {
      const p = STATE.players.get(playerId);
      if (!p) return;
      
      const oldLevel = p.lane;
      p.lane = Math.max(0, Math.min(2, newLevel));
      
      // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ lane - –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª —Å–∞–º –∏–Ω—Ç–µ—Ä–ø–æ–ª–∏—Ä—É–µ—Ç –∫ –Ω–æ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏
      const avatarEl = racePlanState.participants.get(playerId);
      if (avatarEl) {
        // –î–æ–±–∞–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—É—é –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å - –Ω–µ–±–æ–ª—å—à–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏
        avatarEl.classList.add('moving');
        setTimeout(() => {
          avatarEl.classList.remove('moving');
        }, 150);
        
        console.log(`Avatar ${playerId} moved from level ${oldLevel} to level ${newLevel}`);
      }
    }

    // Plane Race State (legacy compatibility)
    const racePlanState = {
      isActive: false,
      participants: new Map(), // userId -> avatar element
      positions: new Map(), // userId -> { x: number, y: number }
      levels: new Map(), // userId -> level (0, 1, 2)
      obstacles: new Map(), // obstacleId -> obstacle element
      winner: null,
      gameOver: false
    };

    function endGame(winnerId, winnerName) {
      console.log(`Game ended! Winner: ${winnerName} (${winnerId})`);
      foodGameState.gameOver = true;
      foodGameState.isActive = false;
      foodGameState.winner = winnerId;
      
      // Show winner message
      const winnerEl = document.getElementById('foodGameWinner');
      winnerEl.textContent = `üèÜ ${winnerName} –ü–û–ë–ï–î–ò–õ! –°–æ–±—Ä–∞–ª 10 –º–æ—Ä–∫–æ–≤–æ–∫!`;
      winnerEl.style.display = 'block';
      
      // Emit food game finish to server
      fetch('/api/food-game/finish', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(withStreamerAuth({ winnerId, winnerName }))
      }).catch(err => console.error('Error finishing food game:', err));
      
        // Hide after 5 seconds and clean up
        setTimeout(() => {
          winnerEl.style.display = 'none';
          document.getElementById('foodGameArea').style.display = 'none';
        
        // Remove food game avatars and clean up
        foodGameState.participants.forEach((avatarEl, userId) => {
          const avatar = avatarEl.querySelector('.avatar');
          if (avatar) {
            stopAvatarIntervals(avatar);
          }
          avatarEl.remove();
          
          // Remove score counter
          const scoreCounter = document.getElementById(`score-${userId}`);
          if (scoreCounter) {
            scoreCounter.remove();
          }
        });
        
        // Remove all carrots
        foodGameState.carrots.forEach(carrot => carrot.remove());
        
        // Clear food game state completely
        foodGameState.participants.clear();
        foodGameState.scores.clear();
        foodGameState.directions.clear();
        foodGameState.carrots.clear();
        foodGameState.speedModifiers.clear();
        foodGameState.winner = null;
        foodGameState.gameOver = false;
        foodGameState.isActive = false;
      }, 5000);
    }

    function startFoodGame(data) {
      console.log('Starting food game with data:', data);
      foodGameState.isActive = true;
      foodGameState.gameOver = false;
      foodGameState.participants.clear();
      foodGameState.scores.clear();
      foodGameState.directions.clear();
      foodGameState.carrots.clear();
      foodGameState.speedModifiers.clear();
      foodGameState.winner = null;

      // Remove all existing avatars from screen
      const existingAvatars = document.querySelectorAll('.avatar');
      existingAvatars.forEach(avatar => {
        // –û—á–∏—â–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º
        stopAvatarIntervals(avatar);
        avatar.remove();
      });
      // –û—á–∏—â–∞–µ–º Map –∞–∫—Ç–∏–≤–Ω—ã—Ö –∞–≤–∞—Ç–∞—Ä–æ–≤
      active.clear();
      lastActivity.clear();
      console.log('Removed all existing avatars for food game');

      // Show food game area
      document.getElementById('foodGameArea').style.display = 'block';
      console.log('Food game area displayed');

      // Create food game avatars for participants
      const createAvatars = async () => {
        for (const participant of data.participants) {
          const userId = typeof participant === 'object' ? participant.userId : participant;
          const displayName = typeof participant === 'object' ? participant.displayName : null;
          await createFoodGameAvatar(userId, displayName);
        }
      };
      createAvatars();

      // Start countdown
      startFoodGameCountdown(data.countdown);
    }

    async function createFoodGameAvatar(userId, displayName) {
      // Load user avatar data
      const userAssets = await loadUserAvatar(userId);
      
      // Create new avatar element
      const foodGameAvatar = document.createElement('div');
      foodGameAvatar.id = `food-game-avatar-${userId}`;
      foodGameAvatar.style.position = 'absolute';
      foodGameAvatar.style.bottom = '20px';
      foodGameAvatar.style.left = '50px';
      foodGameAvatar.style.zIndex = '1000';

      const resolvedDisplayName = displayName || foodGameState.displayNames.get(userId) || null;

      const avatar = document.createElement('div');
      avatar.className = 'avatar';
      avatar.dataset.userId = userId;
      if (resolvedDisplayName) {
        avatar.dataset.displayName = resolvedDisplayName;
      }

      // --- static ---
      const baseLayers = ['body', 'face', 'clothes', 'others'];
      baseLayers.forEach(layer => {
        const img = document.createElement('img');
        img.className = 'layer static';
        img.alt = layer;
        img.src = userAssets[layer];
        avatar.appendChild(img);
      });

      // –ü–æ–¥–≥–æ—Ç–æ–≤–∏–º ID —Å–ª–æ—ë–≤ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–π
      const bodyId    = userAssets.bodyId    || '1';
      const faceId    = userAssets.faceId    || '1';
      const clothesId = userAssets.clothesId || '1';
      const othersId  = userAssets.othersId  || '1';

      // --- walk1 ---
      const walk1Src = {
        body:    `/parts/body_walk_1/body_walk_1_skin_${bodyId}.png`,
        face:    `/parts/face_walk_1/face_walk_1_skin_${faceId}.png`,
        clothes: `/parts/clothes_walk_1/clothes_walk_1_type_${clothesId}.png`,
        others:  `/parts/others_walk_1/others_walk_1_type_${othersId}.png`,
      };
      baseLayers.forEach(layer => {
        const img = document.createElement('img');
        img.className = 'layer walk1';
        img.alt = `${layer}_walk1`;
        img.src = walk1Src[layer];
        avatar.appendChild(img);
      });

      // --- walk2 ---
      const walk2Src = {
        body:    `/parts/body_walk_2/body_walk_2_skin_${bodyId}.png`,
        face:    `/parts/face_walk_2/face_walk_2_skin_${faceId}.png`,
        clothes: `/parts/clothes_walk_2/clothes_walk_2_type_${clothesId}.png`,
        others:  `/parts/others_walk_2/others_walk_2_${othersId}.png`,
      };
      baseLayers.forEach(layer => {
        const img = document.createElement('img');
        img.className = 'layer walk2';
        img.alt = `${layer}_walk2`;
        img.src = walk2Src[layer];
        avatar.appendChild(img);
      });

      // --- tired ---
      const tiredSrc = {
        body:    `/parts/body_tired/body_tired_skin_${bodyId}.png`,
        face:    `/parts/face_tired/face_tired_skin_${faceId}.png`,
        clothes: `/parts/clothes_tired/clothes_tired_type_${clothesId}.png`,
        others:  `/parts/others_tired/others_tired_${othersId}_1.png`,
      };
      baseLayers.forEach(layer => {
        const img = document.createElement('img');
        img.className = 'layer tired';
        img.alt = `${layer}_tired`;
        img.src = tiredSrc[layer];
        avatar.appendChild(img);
      });

      foodGameAvatar.appendChild(avatar);
      document.getElementById('foodGameArea').appendChild(foodGameAvatar);

      // Set initial avatar state to show static layers
      setAvatarState(avatar, 'static');

      // Fix container dimensions to match avatar sprite
      requestAnimationFrame(() => {
        const r = avatar.getBoundingClientRect();
        foodGameAvatar.style.width = r.width + 'px';
        foodGameAvatar.style.height = r.height + 'px';
      });

      // Store in food game state
      foodGameState.participants.set(userId, foodGameAvatar);
      foodGameState.scores.set(userId, 0);
      foodGameState.directions.set(userId, 1); // Start moving right
      foodGameState.speedModifiers.set(userId, 0); // No speed modifier initially
      if (resolvedDisplayName) {
        foodGameState.displayNames.set(userId, resolvedDisplayName);
      }

      // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ static –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏
      setAvatarState(avatar, 'static');

      // --- –ò–ó–ú–ï–ù–ï–ù–û: –°–æ–∑–¥–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –æ—á–∫–æ–≤ –≤–Ω—É—Ç—Ä–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –∞–≤–∞—Ç–∞—Ä–∞ ---
      const scoreCounter = document.createElement('div');
      scoreCounter.className = 'score-counter';
      scoreCounter.textContent = '0';
      scoreCounter.id = `score-${userId}`;
      // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –∞–≤–∞—Ç–∞—Ä–∞
      scoreCounter.style.transformOrigin = 'center'; // –¢–æ—á–∫–∞ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø–æ —Ü–µ–Ω—Ç—Ä—É
      scoreCounter.style.pointerEvents = 'none'; // –ù–µ –º–µ—à–∞–µ—Ç –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—é
      // –î–æ–±–∞–≤–ª—è–µ–º z-index, —á—Ç–æ–±—ã —Å—á–µ—Ç—á–∏–∫ –±—ã–ª –ø–æ–≤–µ—Ä—Ö –∞–≤–∞—Ç–∞—Ä–∞
      scoreCounter.style.zIndex = '1000';
      // –î–æ–±–∞–≤–ª—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π data-–∞—Ç—Ä–∏–±—É—Ç –¥–ª—è –ª–µ–≥–∫–æ–π —Å–≤—è–∑–∏
      scoreCounter.dataset.userId = userId;
      scoreCounter.style.setProperty('--score-flip', '1');

      // –î–æ–±–∞–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫ –≤–Ω—É—Ç—Ä—å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –∞–≤–∞—Ç–∞—Ä–∞, –∞ –Ω–µ –≤ foodGameArea –Ω–∞–ø—Ä—è–º—É—é
      foodGameAvatar.appendChild(scoreCounter);
      console.log(`Created food game avatar and score counter for user: ${userId}`, scoreCounter);
      console.log(`Score counter ID: ${scoreCounter.id}`);
      
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å—á–µ—Ç—á–∏–∫
      updateScoreDisplay(userId, 0);
      // --- –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–ô ---

      console.log(`Created food game avatar for user: ${userId}`);
    }

    function startFoodGameWalkingAnimation(avatar) {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏–π
      setAvatarState(avatar, 'walking');
    }

    function startFoodGameCountdown(count) {
      const countdownEl = document.getElementById('foodGameCountdown');
      countdownEl.style.display = 'block';
      
      let current = count;
      const interval = setInterval(() => {
        if (current > 0) {
          countdownEl.textContent = current;
          current--;
        } else {
          clearInterval(interval);
          countdownEl.style.display = 'none';
          // Wait a bit for avatars to be created
          setTimeout(() => {
            startFoodGameMovement();
          }, 1000);
        }
      }, 1000);
    }

    function startFoodGameMovement() {
      // Start moving avatars
      const moveInterval = setInterval(() => {
        if (!foodGameState.isActive || foodGameState.winner || foodGameState.gameOver) {
          clearInterval(moveInterval);
          return;
        }

        foodGameState.participants.forEach((avatarEl, userId) => {
          const direction = foodGameState.directions.get(userId) || 1;
          const speedModifier = foodGameState.speedModifiers.get(userId) || 0;
          const currentLeft = parseInt(avatarEl.style.left) || 50;
          const baseSpeed = 2; // Base movement speed
          const totalSpeed = baseSpeed + (baseSpeed * speedModifier); // Apply speed modifier
          const newLeft = currentLeft + (direction * totalSpeed);
          
          // Check if avatar hit screen boundaries
          const minLeft = 50;
          const maxLeft = window.innerWidth - 120;
          let newDirection = direction;
          let clampedLeft = newLeft;
          let isMoving = true;
          
          if (newLeft <= minLeft) {
            // Hit left boundary - reverse direction
            clampedLeft = minLeft;
            newDirection = 1; // Move right
            foodGameState.directions.set(userId, newDirection);
          } else if (newLeft >= maxLeft) {
            // Hit right boundary - reverse direction
            clampedLeft = maxLeft;
            newDirection = -1; // Move left
            foodGameState.directions.set(userId, newDirection);
          }
          
          // Check if avatar actually moved
          if (Math.abs(clampedLeft - currentLeft) < 0.1) {
            isMoving = false;
          }
          
          avatarEl.style.left = clampedLeft + 'px';
          
          // Start or stop walking animation based on movement
          const avatar = avatarEl.querySelector('.avatar');
          if (avatar) {
            if (isMoving && !avatar.classList.contains('walking')) {
              // Start walking animation
              setAvatarState(avatar, 'walking');
            } else if (!isMoving && !avatar.classList.contains('static')) {
              // Stop walking animation and make static
              setAvatarState(avatar, 'static');
            }
          }
          
          // Flip only the inner .avatar, not the whole container
          if (avatar) {
            avatar.style.transform = (newDirection > 0) ? 'scaleX(1)' : 'scaleX(-1)';
          }

          // keep classes for CSS hooks
          avatarEl.classList.toggle('moving-right', newDirection > 0);
          avatarEl.classList.toggle('moving-left', newDirection < 0);
          
        });

        // --- –£–ª—É—á—à–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π ---
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ö–ê–ñ–î–£–Æ –º–æ—Ä–∫–æ–≤–∫—É –Ω–∞ –∫–æ–ª–ª–∏–∑–∏—é —Å –ö–ê–ñ–î–´–ú —É—á–∞—Å—Ç–Ω–∏–∫–æ–º
        foodGameState.participants.forEach((avatarElement, userId) => {
            const avatarNode = avatarElement.querySelector('.avatar') || avatarElement;
            const avatarRect = avatarNode.getBoundingClientRect();
            const avatarLeft = avatarRect.left;
            const avatarRight = avatarRect.right;
            const avatarTop = avatarRect.top;
            const avatarBottom = avatarRect.bottom;

            // –ò—Ç–µ—Ä–∏—Ä—É–µ–º –ø–æ –∫–æ–ø–∏–∏ —Å–ø–∏—Å–∫–∞ –º–æ—Ä–∫–æ–≤–æ–∫, —á—Ç–æ–±—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ —É–¥–∞–ª—è—Ç—å
            foodGameState.carrots.forEach((carrotElement, carrotId) => {
                if (carrotElement.dataset.collected === 'true') {
                    return;
                }
                const carrotRect = carrotElement.getBoundingClientRect();
                const carrotLeft = carrotRect.left;
                const carrotRight = carrotRect.right;
                const carrotTop = carrotRect.top;
                const carrotBottom = carrotRect.bottom;

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤ (AABB - Axis-Aligned Bounding Box)
                if (avatarLeft < carrotRight &&
                    avatarRight > carrotLeft &&
                    avatarTop < carrotBottom &&
                    avatarBottom > carrotTop) {

                    // --- –ö–æ–ª–ª–∏–∑–∏—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∞ ---
                    console.log(`Collision detected between user ${userId} and carrot ${carrotId}`);

                    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –º–æ—Ä–∫–æ–≤–∫–∞ "–ø—Ä–∏–∑–µ–º–ª–∏–≤—à–µ–π—Å—è"
                    const isGrounded = carrotElement.classList.contains('grounded');

                carrotElement.dataset.collected = 'true';

                    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫ –æ—á–∫–æ–≤
                    let currentScore = foodGameState.scores.get(userId) || 0;
                    // –ó–∞ –∫–∞–∂–¥—É—é –º–æ—Ä–∫–æ–≤–∫—É –¥–∞–µ—Ç—Å—è 1 –æ—á–∫–æ
                    currentScore += 1;
                    foodGameState.scores.set(userId, currentScore);

                    // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—á–µ—Ç—á–∏–∫–∞
                    updateScoreDisplay(userId, currentScore);
                    console.log(`Updated score for user ${userId} to ${currentScore}`);

                    // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç —Å–±–æ—Ä–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∞–Ω–∏–º–∞—Ü–∏—è –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è)
                    carrotElement.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                    carrotElement.style.opacity = '0';
                    carrotElement.style.transform = 'scale(0.5)';

                    // –£–¥–∞–ª—è–µ–º –º–æ—Ä–∫–æ–≤–∫—É –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏ DOM –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
                    setTimeout(() => {
                        if (carrotElement.parentNode) {
                            carrotElement.remove();
                        }
                        foodGameState.carrots.delete(carrotId);
                    }, 300); // –î–æ–ª–∂–Ω–æ —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é transition

                    // --- –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è ---
                    if (currentScore >= 10 && !foodGameState.winner) {
                        foodGameState.winner = userId;
                        foodGameState.isActive = false; // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–≥—Ä—É

                        // –û—á–∏—â–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª –¥–≤–∏–∂–µ–Ω–∏—è
                        clearInterval(moveInterval);
                        foodGameState.moveInterval = null;

                    // –ü–æ–ª—É—á–∞–µ–º –∏–º—è –ø–æ–±–µ–¥–∏—Ç–µ–ª—è –∏–∑ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
                    let winnerName = foodGameState.displayNames.get(userId);
                    if (!winnerName) {
                        const winnerAvatar = foodGameState.participants.get(userId);
                        winnerName = winnerAvatar ? winnerAvatar.querySelector('.avatar')?.dataset.displayName : null;
                    }
                    if (!winnerName) {
                        const avatarData = userAvatars.get(userId);
                        if (avatarData && avatarData.username) {
                            winnerName = avatarData.username;
                        }
                    }
                    if (!winnerName) {
                        winnerName = `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${userId}`;
                    }

                        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ —Å–µ—Ä–≤–µ—Ä –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∏–≥—Ä—ã –∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
                        fetch('/api/food-game/finish', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(withStreamerAuth({ winnerId: userId, winnerName }))
                        }).catch(err => console.error('Error finishing food game:', err));

                        // --- –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∏–≥—Ä—ã ---
                        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏–∏ —É –≤—Å–µ—Ö –∞–≤–∞—Ç–∞—Ä–æ–≤
                        foodGameState.participants.forEach(avatarEl => {
                            const avatar = avatarEl.querySelector('.avatar');
                            if (avatar) {
                                setAvatarState(avatar, 'static'); // –ò—Å–ø–æ–ª—å–∑–µ–º –Ω–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏–π
                            }
                        });

                        // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –ø–æ–±–µ–¥–∏—Ç–µ–ª—è –ø–æ —Ü–µ–Ω—Ç—Ä—É
                        const winnerAvatar = foodGameState.participants.get(userId);
                        if (winnerAvatar) {
                            winnerAvatar.style.left = '50%';
                            winnerAvatar.style.transform = 'translateX(-50%)'; // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º
                            // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –∞–≤–∞—Ç–∞—Ä –ø–æ–±–µ–¥–∏—Ç–µ–ª—è —Å—Ç–∞—Ç–∏—á–µ–Ω
                            const avatar = winnerAvatar.querySelector('.avatar');
                            if (avatar) {
                                setAvatarState(avatar, 'static');
                            }
                        }

                        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ
                        const winnerEl = document.getElementById('foodGameWinner');
                        if (winnerEl) {
                            winnerEl.textContent = `üèÜ ${winnerName} –ü–û–ë–ï–î–ò–õ!`;
                            winnerEl.style.display = 'block';
                        }

                        // –°–∫—Ä—ã–≤–∞–µ–º –∏–≥—Ä–æ–≤—É—é –æ–±–ª–∞—Å—Ç—å –∏ –æ—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥
                        setTimeout(() => {
                            if (winnerEl) winnerEl.style.display = 'none';
                            const foodGameArea = document.getElementById('foodGameArea');
                            if (foodGameArea) foodGameArea.style.display = 'none';

                            // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
                            foodGameState.participants.clear();
                            foodGameState.scores.clear();
                            foodGameState.directions.clear();
                            foodGameState.speedModifiers.clear();
                            foodGameState.carrots.forEach(c => c.remove()); // –£–¥–∞–ª—è–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –º–æ—Ä–∫–æ–≤–∫–∏ –∏–∑ DOM
                            foodGameState.carrots.clear();
                            foodGameState.winner = null;
                            foodGameState.isActive = false;
                            // –û—á–∏—â–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª, –µ—Å–ª–∏ –æ–Ω –∫–∞–∫–∏–º-—Ç–æ –æ–±—Ä–∞–∑–æ–º –æ—Å—Ç–∞–ª—Å—è
                            if (foodGameState.moveInterval) {
                                 clearInterval(foodGameState.moveInterval);
                                 foodGameState.moveInterval = null;
                            }

                        }, 5000);
                    }
                    // --- –ö–æ–Ω–µ—Ü –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è ---

                }
            });
        });
        // --- –ö–æ–Ω–µ—Ü —É–ª—É—á—à–µ–Ω–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–ª–ª–∏–∑–∏–π ---
      }, 33); // Update every 33ms (~30fps) for smoother movement
    }

    function startFoodGameMonitoring(data) {
      console.log('Starting food game monitoring with data:', data);
      // Initialize scores, directions and speed modifiers
      data.participants.forEach(participant => {
        if (!participant) return;
        const userId = typeof participant === 'object' ? participant.userId : participant;
        if (!userId) return;
        const displayName = typeof participant === 'object' ? participant.displayName : null;
        const score = (data.scores && data.scores[userId]) || 0;

        foodGameState.scores.set(userId, score);
        foodGameState.directions.set(userId, (data.directions && data.directions[userId]) || 1);
        foodGameState.speedModifiers.set(userId, (data.speedModifiers && data.speedModifiers[userId]) || 0);
        if (displayName) {
          foodGameState.displayNames.set(userId, displayName);
        }

        // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—á–µ—Ç—á–∏–∫–∞
        updateScoreDisplay(userId, score);
      });
    }

    function updateFoodGameDirection(userId, direction) {
      foodGameState.directions.set(userId, direction);
      console.log(`Updated direction for user ${userId}: ${direction > 0 ? 'right' : 'left'}`);
    }

    function updateFoodGameSpeed(userId, speedModifier) {
      foodGameState.speedModifiers.set(userId, speedModifier);
      console.log(`Updated speed modifier for user ${userId}: ${speedModifier}`);
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∞–≤–∞—Ç–∞—Ä–∞ (normal/tired)
    function updateAvatarState(userId, state) {
      const avatar = document.getElementById(`avatar-${userId}`);
      if (!avatar) return;
      
      console.log(`[overlay] Updating avatar ${userId} to state: ${state}`);
      
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é setAvatarState –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏
      if (state === 'tired') {
        setAvatarState(avatar, 'tired');
        console.log(`Avatar ${userId} is now tired`);
      } else if (state === 'normal') {
        setAvatarState(avatar, 'static'); // normal = static —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        console.log(`Avatar ${userId} is now normal`);
      }
    }

    // Duplicate removeAvatar function removed - using the correct one above

    function spawnCarrot(data) {
      const carrot = document.createElement('div');
      carrot.className = 'carrot';
      carrot.id = `carrot-${data.id}`;
      carrot.style.position = 'absolute';
      carrot.style.left = data.x + 'px';
      carrot.style.top = data.y + 'px';
      carrot.style.width = '40px';
      carrot.style.height = '40px';
      carrot.style.background = 'url(/parts/carrot.svg) no-repeat center';
      carrot.style.backgroundSize = 'contain';
      carrot.style.zIndex = '500';
      carrot.dataset.speed = data.speed;
      carrot.dataset.collected = 'false';

      document.getElementById('foodGameArea').appendChild(carrot);
      foodGameState.carrots.set(data.id, carrot);

      // Start falling animation
      const fallInterval = setInterval(() => {
        // Stop if game is over
        if (foodGameState.gameOver) {
          clearInterval(fallInterval);
          return;
        }
        
        const currentTop = parseInt(carrot.style.top) || 0;
        const speed = parseFloat(carrot.dataset.speed) || 2;
        const newTop = currentTop + speed;
        
        carrot.style.top = newTop + 'px';
        
        // Check if carrot reached ground level (29px higher than avatars)
        const groundLevel = window.innerHeight - 49; // 20px (avatar bottom) + 29px = 49px
        if (newTop >= groundLevel && !carrot.dataset.grounded) {
          carrot.dataset.grounded = 'true';
          carrot.style.top = groundLevel + 'px';
          carrot.classList.add('grounded');
          
          // Stay on ground for 3 seconds
          setTimeout(() => {
            if (carrot.dataset.collected !== 'true') {
              carrot.remove();
              foodGameState.carrots.delete(data.id);
            }
          }, 3000);
          
          clearInterval(fallInterval);
        }
        
        // Remove if fallen off screen (before reaching ground)
        if (newTop > window.innerHeight && !carrot.dataset.grounded) {
          clearInterval(fallInterval);
          carrot.remove();
          foodGameState.carrots.delete(data.id);
        }
        
        // Check for collisions - moved to startFoodGameMovement for better performance
      }, 8); // ~120fps –¥–ª—è –±–æ–ª–µ–µ –æ—Ç–∑—ã–≤—á–∏–≤–æ–π –∫–æ–ª–ª–∏–∑–∏–∏
    }

    function removeCarrot(carrotId) {
      const carrot = foodGameState.carrots.get(carrotId);
      if (carrot) {
        carrot.remove();
        foodGameState.carrots.delete(carrotId);
      }
    }

    function checkCarrotCollisions() {
      if (foodGameState.gameOver) return;
      
      // Disabled - collision detection moved to startFoodGameMovement for better performance
      return;
      
      foodGameState.participants.forEach((avatarEl, userId) => {
        const avatarRect = avatarEl.getBoundingClientRect();
        
        // Create collision box based on avatar size (160x240)
        const avatar = {
          x: avatarRect.left,
          y: avatarRect.top,
          width: 160,
          height: 240
        };
        
        foodGameState.carrots.forEach((carrot, carrotId) => {
          if (carrot.dataset.collected === 'true') return;
          
          const carrotRect = carrot.getBoundingClientRect();
          
          // Create carrot collision box
          const carrotBox = {
            x: carrotRect.left,
            y: carrotRect.top,
            width: carrotRect.width,
            height: carrotRect.height
          };
          
          // Check collision using proper rectangle intersection
          const collision = !(
            avatar.x + avatar.width < carrotBox.x ||
            avatar.x > carrotBox.x + carrotBox.width ||
            avatar.y + avatar.height < carrotBox.y ||
            avatar.y > carrotBox.y + carrotBox.height
          );
          
          if (collision) {
            // Collect carrot
            carrot.dataset.collected = 'true';
            carrot.style.opacity = '0';
            carrot.style.transform = 'scale(1.5)';
            carrot.classList.remove('grounded');
            
            // Update score
            const currentScore = foodGameState.scores.get(userId) || 0;
            const newScore = currentScore + 1;
            foodGameState.scores.set(userId, newScore);
            
            // Update score display
            updateScoreDisplay(userId, newScore);
            
            // Emit score update
            fetch('/api/food-game/score-update', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(withStreamerAuth({ userId, score: newScore }))
            }).catch(err => console.error('Error updating score:', err));
            
            // Remove carrot after animation
            setTimeout(() => {
              carrot.remove();
              foodGameState.carrots.delete(carrotId);
            }, 200);
            
            console.log(`User ${userId} collected ${isGrounded ? 'grounded' : 'falling'} carrot! Score: ${newScore}`);
            
            // Check for winner - end game at 10 carrots
            if (newScore >= 10) {
              // Get winner name from avatar element
              const winnerName = foodGameState.displayNames.get(userId) || (() => {
                const winnerAvatar = foodGameState.participants.get(userId);
                return winnerAvatar ? winnerAvatar.querySelector('.avatar')?.dataset.displayName || 'Unknown' : 'Unknown';
              })();
              
              console.log(`Game finished! Winner: ${winnerName} (${userId}) with score: ${newScore}`);
              
              // End the game
              endGame(userId, winnerName);
            }
          }
        });
      });
    }

    function updateFoodGameScore(userId, score) {
      foodGameState.scores.set(userId, score);
      updateScoreDisplay(userId, score);
      console.log(`Updated score for user ${userId}: ${score}`);
    }

    function updateScoreDisplay(userId, score) {
      const avatarEl = foodGameState.participants.get(userId);
      if (!avatarEl) {
        console.log(`No avatar found for user ${userId}`);
        return;
      }

      let scoreCounter = document.getElementById(`score-${userId}`);
      console.log(`updateScoreDisplay: Looking for score counter with ID score-${userId}`, scoreCounter);
      if (!scoreCounter) {
        // –°–æ–∑–¥–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
        scoreCounter = document.createElement('div');
        scoreCounter.className = 'score-counter';
        scoreCounter.id = `score-${userId}`;
        scoreCounter.dataset.userId = userId;
        scoreCounter.style.transformOrigin = 'center';
        scoreCounter.style.pointerEvents = 'none';
        avatarEl.appendChild(scoreCounter);
      }

      scoreCounter.textContent = score;
      console.log(`updateScoreDisplay: Set score counter text to ${score} for user ${userId}`);
      
      // –í–∏–∑—É–∞–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–µ–∑ –∞–Ω–∏–º–∞—Ü–∏–∏
      scoreCounter.classList.add('updated');
      setTimeout(() => {
         scoreCounter.classList.remove('updated');
      }, 500);

    }


    function finishFoodGame(data) {
      foodGameState.isActive = false;
      foodGameState.winner = data.winner;
      
      // Move winner to center and make static
      const winnerAvatar = foodGameState.participants.get(data.winner);
      if (winnerAvatar) {
        winnerAvatar.style.left = '50%';
        winnerAvatar.style.transform = 'translateX(-50%)';
        
        // Stop walking animation and make static
        const avatar = winnerAvatar.querySelector('.avatar');
        if (avatar) {
          // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏–π
          setAvatarState(avatar, 'static');
        }
      }
      
      // Show winner
      const winnerEl = document.getElementById('foodGameWinner');
      const winnerName = data.winnerName || `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${data.winner}`;
      winnerEl.textContent = `üèÜ ${winnerName} –ü–û–ë–ï–î–ò–õ!`;
      winnerEl.style.display = 'block';
      
      // Hide after 5 seconds
      setTimeout(() => {
        winnerEl.style.display = 'none';
        document.getElementById('foodGameArea').style.display = 'none';
        
        // Remove food game avatars and clean up
        foodGameState.participants.forEach((avatarEl, userId) => {
          const avatar = avatarEl.querySelector('.avatar');
          if (avatar) {
            stopAvatarIntervals(avatar);
          }
          avatarEl.remove();
          
          // Remove score counter
          const scoreCounter = document.getElementById(`score-${userId}`);
          if (scoreCounter) {
            scoreCounter.remove();
          }
        });
        
        // Remove all carrots
        foodGameState.carrots.forEach(carrot => carrot.remove());
        
        // Clear food game state completely
        foodGameState.participants.clear();
        foodGameState.scores.clear();
        foodGameState.directions.clear();
        foodGameState.carrots.clear();
        foodGameState.speedModifiers.clear();
        foodGameState.winner = null;
        foodGameState.isActive = false;
      }, 5000);
    }

    // Plane Race Functions
    async function startRacePlan(data) {
      console.log('Starting plane race with data:', data);
      console.log('Data participants:', data.participants);
      console.log('Data countdown:', data.countdown);
      racePlanState.isActive = true;
      racePlanState.gameOver = false;
      racePlanState.participants.clear();
      racePlanState.positions.clear();
      racePlanState.levels.clear();
      racePlanState.obstacles.clear();
      racePlanState.winner = null;

      // Remove all existing avatars from screen
      const existingAvatars = document.querySelectorAll('.race-plan-avatar');
      existingAvatars.forEach(avatar => avatar.remove());
      console.log('Removed all existing avatars for race plan');

      // Show plane race area
      const racePlanArea = document.getElementById('racePlanArea');
      if (racePlanArea) {
        racePlanArea.style.display = 'block';
        // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã—Å–æ—Ç—É –µ—Å–ª–∏ –æ–Ω–∞ –Ω—É–ª–µ–≤–∞—è
        if (racePlanArea.clientHeight === 0) {
          racePlanArea.style.height = 'var(--race-h)'; // –≤–º–µ—Å—Ç–æ 100vh
          console.log('Fixed racePlanArea height to var(--race-h)');
        }
        console.log('Plane race area displayed, computed style:', window.getComputedStyle(racePlanArea).display);
        console.log('Plane race area dimensions:', racePlanArea.clientWidth, racePlanArea.clientHeight);
      } else {
        console.error('racePlanArea element not found!');
      }
      
      const levelIndicator = document.getElementById('levelIndicator');
      if (levelIndicator) {
        levelIndicator.style.display = 'flex';
        console.log('Level indicator displayed');
      } else {
        console.error('levelIndicator element not found!');
      }

      // Create plane race avatars for participants
      const createAvatars = async () => {
        console.log('Creating avatars for participants:', data.participants);
        if (!data.participants || data.participants.length === 0) {
          console.log('No participants to create avatars for');
          return;
        }
        for (let index = 0; index < data.participants.length; index++) {
          const userId = data.participants[index];
          console.log(`Creating avatar for participant ${index}: ${userId}`);
          await createPlaneRaceAvatar(userId, index);
        }
      };
      await createAvatars();

      // –ñ–¥—ë–º –ø–æ–∫–∞ –ø—Ä–∏–¥—É—Ç —É—Ä–æ–≤–Ω–∏ —Ö–æ—Ç—è –±—ã 200‚Äì300–º—Å (–∏–ª–∏ –ø–æ–∫–∞ levels –Ω–µ –∑–∞–ø–æ–ª–Ω–∏—Ç—Å—è)
      await new Promise(r => setTimeout(r, 250));
      
      // –ü–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –∞–≤–∞—Ç–∞—Ä–æ–≤ - –ø–æ–¥–≥–æ—Ç–æ–≤–∏–º STATE.players —Å –Ω–∞—á–∞–ª—å–Ω—ã–º–∏ –ø–æ–ª–æ—Å–∞–º–∏
      console.log('startRacePlan: preparing players before countdown');
      preparePlayersBeforeCountdown();
      
      // –ü—Ä–∞–≤–∏–ª—å–Ω–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∞–≤–∞—Ç–∞—Ä—ã –¥–æ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞
      console.log('startRacePlan: placing players at lanes before start');
      await placePlayersAtLanesBeforeStart();

      // Start countdown
      console.log('startRacePlan: starting countdown');
      startPlaneRaceCountdown(Number.isFinite(+data.countdown) ? +data.countdown : 3);
    }

    async function createPlaneRaceAvatar(userId, index) {
      // Load user avatar data
      const userAssets = await loadUserAvatar(userId);
      
      // Create new avatar element
      const racePlanAvatar = document.createElement('div');
      racePlanAvatar.id = `race-plan-avatar-${userId}`;
      racePlanAvatar.className = 'race-plan-avatar';
      racePlanAvatar.style.position = 'absolute';
      racePlanAvatar.style.zIndex = '1000';
      // –ù–µ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º left - –±—É–¥–µ—Ç –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞—Ç—å—Å—è —á–µ—Ä–µ–∑ transform –≤ placePlayersAtLanesBeforeStart

      const avatar = document.createElement('div');
      avatar.className = 'avatar';
      avatar.dataset.userId = userId;

      // Create static layers
      const baseLayers = ['body', 'face', 'clothes', 'others'];
      baseLayers.forEach((layer, index) => {
        const img = document.createElement('img');
        img.className = 'layer static';
        img.alt = layer;
        img.src = userAssets[layer];
        // –ü–µ—Ä–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (body) –ø–æ–º–µ—á–∞–µ–º –∫–∞–∫ hitbox-target
        if (index === 0) {
          img.classList.add('hitbox-target');
        }
        avatar.appendChild(img);
      });

      racePlanAvatar.appendChild(avatar);

      // Create lives display (hearts)
      const livesDisplay = document.createElement('div');
      livesDisplay.className = 'lives-display';
      livesDisplay.id = `lives-${userId}`;
      racePlanAvatar.appendChild(livesDisplay);

      document.getElementById('racePlanArea').appendChild(racePlanAvatar);

      // Store in plane race state (—É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º levels –î–û –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è)
      racePlanState.participants.set(userId, racePlanAvatar);
      racePlanState.positions.set(userId, { x: 50, y: 0 });
      racePlanState.levels.set(userId, 1); // Start at middle level
      racePlanState.lives.set(userId, 3); // Start with 3 lives

      // Set initial state
      setAvatarState(avatar, 'static');

      // 1) –°–Ω–∞—á–∞–ª–∞ ‚Äî —Ä–∞–∑–º–µ—Ä—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –æ—Ç —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Å–ø—Ä–∞–π—Ç–∞
      const img = avatar.querySelector('.layer.static');
      const SCALE = 0.4;
      const naturalW = img?.naturalWidth || 140;
      const naturalH = img?.naturalHeight || 180;
      racePlanAvatar.style.setProperty('--avatar-w', `${Math.round(naturalW * SCALE)}px`);
      racePlanAvatar.style.setProperty('--avatar-h', `${Math.round(naturalH * SCALE)}px`);

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è
      racePlanAvatar._x = 50;
      racePlanAvatar.style.position = 'absolute';

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–π
      updateLivesDisplay(userId, 3);

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –º–µ—Ç—Ä–∏–∫–∏ —Ö–∏—Ç–±–æ–∫—Å–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
      setTimeout(() => {
        const { halfW, halfH } = measureHalfSizes(racePlanAvatar);
       fetch('/api/race-plan/avatar-metrics', {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(withStreamerAuth({ userId, halfW, halfH }))
       }).catch(console.error);
      }, 100);

      console.log(`Created plane race avatar for user: ${userId}`);
    }


    function updateLevelIndicator(activeLevel) {
      const levelLines = document.querySelectorAll('.level-line');
      levelLines.forEach((line, index) => {
        if (index === activeLevel) {
          line.classList.add('active');
        } else {
          line.classList.remove('active');
        }
      });
    }

    function startPlaneRaceCountdown(count) {
      const countdownEl = document.getElementById('racePlanCountdown');
      countdownEl.style.display = 'block';
      
      let current = count;
      const interval = setInterval(() => {
        if (current > 0) {
          countdownEl.textContent = current;
          current--;
        } else {
          clearInterval(interval);
          countdownEl.style.display = 'none';
          setTimeout(() => {
            startPlaneRaceMovement();
          }, 1000);
        }
      }, 1000);
    }

    /* === –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª —Å requestAnimationFrame === */
    let rafId = null;
    let lastFrameTime = 0;
    const TARGET_FPS = 60;
    const FRAME_TIME = 1000 / TARGET_FPS; // ~16.7ms
    const AVATAR_SPEED = 1.5; // –ø–∏–∫—Å–µ–ª–µ–π –∑–∞ –∫–∞–¥—Ä (—É–º–µ–Ω—å—à–µ–Ω–æ –≤ 2 —Ä–∞–∑–∞)
    
    function gameLoop(currentTime) {
      // —Ä–∞–Ω–Ω–∏–π –≤—ã—Ö–æ–¥ –¥–ª—è –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ–π –≥–æ–Ω–∫–∏
      if (!STATE.started || STATE.finished) {
        // console.log('Game loop: early return, started:', STATE.started, 'finished:', STATE.finished);
        rafId = requestAnimationFrame(gameLoop);
        return;
      }
      
      // console.log('Game loop running: players=', STATE.players.size, 'obstacles=', OBST.size);

      // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º FPS –∏ –∑–∞—â–∏—â–∞–µ–º—Å—è –æ—Ç –ª–∞–≥–æ–≤
      const deltaTime = Math.min(50, currentTime - lastFrameTime || FRAME_TIME);
      lastFrameTime = currentTime;

      // –ü–ª–∞–≤–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –¥–≤–∏–∂–µ–Ω–∏—è –∞–≤–∞—Ç–∞—Ä–æ–≤ –∫ —Å–µ—Ä–≤–µ—Ä–Ω—ã–º –ø–æ–∑–∏—Ü–∏—è–º
      STATE.players.forEach((p, id) => {
        if (p.out) return;
        
        // –ò–Ω—Ç–µ—Ä–ø–æ–ª–∏—Ä—É–µ–º –∫ —Å–µ—Ä–≤–µ—Ä–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
        if (p.serverX !== undefined) {
          p.x = p.x + (p.serverX - p.x) * 0.15; // –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è
        }
        
        // –†–µ–Ω–¥–µ—Ä–∏–º –ø–æ–∑–∏—Ü–∏—é –∞–≤–∞—Ç–∞—Ä–∞ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º–∏ –ø–æ –≥—Ä–∞–Ω–∏—Ü–∞–º
        const { w, h } = measureAvatar(p.el);
        
        // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        const trackEl = document.querySelector('#racePlanArea');
        const trackRect = trackEl ? trackEl.getBoundingClientRect() : { width: 800, height: 360 };
        
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º X –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        const rawX = (p.x ?? 50) - Math.round(w / 2);
        const x = Math.max(0, Math.min(rawX, trackRect.width - w));
        
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º Y –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ —Ñ–æ—Ä–º—É–ª—É —á—Ç–æ –∏ –¥–ª—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
        const rawY = laneCenterY(p.lane) - h / 2;
        const y = Math.max(0, Math.min(rawY, trackRect.height - h));

        // –í–ê–ñ–ù–û: –∑–¥–µ—Å—å —Ç–æ–ª—å–∫–æ translate, –±–µ–∑ scale/rotate!
        p.el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º dataset –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        p.el.dataset.x = x.toFixed(1);
        p.el.dataset.lane = p.lane;
        
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–∏–Ω–∏—à
        checkRacePlanFinish(p, id);
      });

      // –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è –¥–≤–∏–≥–∞–µ—Ç —Å–µ—Ä–≤–µ—Ä; –∑–¥–µ—Å—å —Ç–æ–ª—å–∫–æ –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –∫ —Å–µ—Ä–≤–µ—Ä–Ω—ã–º –ø–æ–∑–∏—Ü–∏—è–º
      if (SERVER_OBSTACLE_SYNC) {
        OBST.forEach(rec => {
          // –õ—ë–≥–∫–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –∫ serverX
          rec.x = rec.x + (rec.serverX - rec.x) * 0.25; // –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è
          const y = laneCenterY(rec.lane);
          const el = rec.el;
          
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º transform –¥–ª—è –ø–ª–∞–≤–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏
        el.style.transform = `translate3d(${rec.x.toFixed(1)}px, ${y - el.clientHeight/2}px, 0)`;
          
          // –û–±–Ω–æ–≤–ª—è–µ–º dataset –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
          el.dataset.x = rec.x.toFixed(1);
          el.dataset.lane = rec.lane;

          // —É–¥–∞–ª–∏—Ç—å –∑–∞ —ç–∫—Ä–∞–Ω–æ–º
          if (rec.x + el.clientWidth < -50) {
            el.remove();
            OBST.delete(el.dataset.id);
          }
        });
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏ (–∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ –∏–≥—Ä–µ "–°–æ–±–µ—Ä–∏ –º–æ—Ä–∫–æ–≤–∫—É")
      // checkRacePlanCollisions(); // –û—Ç–∫–ª—é—á–µ–Ω–æ - –∫–æ–ª–ª–∏–∑–∏–∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ

      // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ü–∏–∫–ª
      rafId = requestAnimationFrame(gameLoop);
    }
    
    function startLoop() {
      console.log('=== STARTING GAME LOOP ===');
      cancelAnimationFrame(rafId);
      lastFrameTime = 0;
      rafId = requestAnimationFrame(gameLoop);
      console.log('Game loop started with rafId:', rafId);
    }
    
    function stopLoop() {
      cancelAnimationFrame(rafId);
      rafId = null;
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–π –≤—ã—Å–æ—Ç—ã race-plan
    function setRaceHeight() {
      // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è, –Ω–æ ¬´—Ä–∞–∑—É–º–Ω–∞—è¬ª –≤—ã—Å–æ—Ç–∞ –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞:
      // –æ—Ç 260px –¥–æ 460px, —Ü–µ–ª–∏–º—Å—è –ø—Ä–∏–º–µ—Ä–Ω–æ –≤ 35% –≤—ã—Å–æ—Ç—ã –æ–∫–Ω–∞
      const h = Math.round(Math.max(260, Math.min(window.innerHeight * 0.35, 460)));
      document.documentElement.style.setProperty('--race-h', h + 'px');
    }

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—ã—Å–æ—Ç—ã –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
    window.addEventListener('resize', setRaceHeight);
    setRaceHeight();

    // –ù–∞ —Ä–µ—Å–∞–π–∑ ‚Äî –ø–µ—Ä–µ—Ä–∞—Å—Å—Ç–∞–≤–∏—Ç—å –ø–æ —Ü–µ–Ω—Ç—Ä–∞–º –ø–æ–ª–æ—Å –∏ –ø–µ—Ä–µ—Å—á–∏—Ç–∞—Ç—å –ø–æ–∑–∏—Ü–∏–∏ —Å–µ—Ä–¥–µ—á–µ–∫
    window.addEventListener('resize', () => {
      // –û–±–Ω–æ–≤–ª—è–µ–º –≤—ã—Å–æ—Ç—É race-plan –ø—Ä–∏ —Ä–µ—Å–∞–π–∑–µ
      setRaceHeight();
      
      // 1) –ü–µ—Ä–µ—Å—á–∏—Ç–∞—Ç—å Y –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π (—É —Ç–µ–±—è —É–∂–µ –µ—Å—Ç—å)
      OBST.forEach(rec => {
        const y = laneCenterY(rec.lane);
        rec.el.style.transform =
          `translate3d(${Math.round(rec.x)}px, ${y - rec.el.clientHeight/2}px, 0)`;
      });

      // 2) –ü–µ—Ä–µ—Å—á–∏—Ç–∞—Ç—å Y –∞–≤–∞—Ç–∞—Ä–æ–≤ (–≤–æ—Ç —ç—Ç–æ–≥–æ –Ω–µ —Ö–≤–∞—Ç–∞–ª–æ)
      STATE.players.forEach((p) => {
        if (!p || !p.el || p.out) return;
        const { w, h } = measureAvatar(p.el);
        
        // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        const trackEl = document.querySelector('#racePlanArea');
        const trackRect = trackEl ? trackEl.getBoundingClientRect() : { width: 800, height: 360 };
        
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º X –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        const rawX = (p.x ?? 50) - Math.round(w / 2);
        const x = Math.max(0, Math.min(rawX, trackRect.width - w));
        
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º Y –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ —Ñ–æ—Ä–º—É–ª—É —á—Ç–æ –∏ –¥–ª—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
        const rawY = laneCenterY(p.lane) - h / 2;
        const y = Math.max(0, Math.min(rawY, trackRect.height - h));
        
        p.el.style.transition = 'none';                           // –±–µ–∑ –∞–Ω–∏–º–∞—Ü–∏–∏
        p.el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
        // –≤–µ—Ä–Ω—É—Ç—å transition –Ω–∞ –º–µ—Å—Ç–æ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –∫–∞–¥—Ä, –µ—Å–ª–∏ –æ–Ω –±—ã–ª
        requestAnimationFrame(() => { p.el.style.transition = ''; });
      });

      // 3) –ü–µ—Ä–µ—Ä–∏—Å–æ–≤–∞—Ç—å ¬´–≥—Ä–∞–Ω–∏—Ü—ã –¥–æ—Ä–æ–∂–µ–∫¬ª –¥–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ—Å—Ç–∏/–∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
      createLaneBoundaries();
      
      // 4) –ò –æ–±–Ω–æ–≤–∏—Ç—å —à–∏—Ä–∏–Ω—É —Ç—Ä–µ–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ (—É —Ç–µ–±—è —ç—Ç–æ —É–∂–µ –µ—Å—Ç—å)
      updateTrackWidth();
    });

    function updateTrackWidth() {
      const trackEl = document.querySelector('#racePlanArea');
      if (trackEl) {
        const trackWidth = trackEl.clientWidth;
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —à–∏—Ä–∏–Ω—ã —Ç—Ä–µ–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
       fetch('/api/race-plan/update-track-width', {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(withStreamerAuth({ trackWidth }))
       }).catch(err => console.error('Error updating track width:', err));
      }
    }

    function startPlaneRaceMovement() {
      // –û–±–Ω–æ–≤–ª—è–µ–º —à–∏—Ä–∏–Ω—É —Ç—Ä–µ–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
      updateTrackWidth();
      
      // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º —Å—Ç–∞—Ä–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å –Ω–æ–≤—ã–º
      racePlanState.participants.forEach((avatarEl, userId) => {
        const existingEl = document.getElementById(`race-plan-avatar-${userId}`);
        if (existingEl && !STATE.players.has(userId)) {
          STATE.players.set(userId, {
            el: existingEl,
            lane: racePlanState.levels.get(userId) || 1,
            x: 50, // –Ω–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
            serverX: 50, // —Ü–µ–ª–µ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è
            out: false
          });
        }
      });
      
      // –°–æ–∑–¥–∞–µ–º –Ω–µ–≤–∏–¥–∏–º—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã –¥–æ—Ä–æ–∂–µ–∫ (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
      createLaneBoundaries();
      
      // –ñ—ë—Å—Ç–∫–∏–π —Ä–µ—Å–µ—Ç —Ñ–ª–∞–≥–æ–≤ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º —Ü–∏–∫–ª–∞
      STATE.finished = false;
      STATE.started = true;
      startLoop(); // –∑–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è –∞–≤–∞—Ç–∞—Ä–æ–≤
    }

    function createLaneBoundaries() {
      // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã –µ—Å–ª–∏ –µ—Å—Ç—å
      document.querySelectorAll('.lane-boundary, .finish-line').forEach(el => el.remove());
      
      const track = document.querySelector('#racePlanArea');
      const h = track.clientHeight;
      const laneHeight = h / 3;
      
      // –°–æ–∑–¥–∞–µ–º –Ω–µ–≤–∏–¥–∏–º—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã –¥–æ—Ä–æ–∂–µ–∫
      for (let i = 0; i < 3; i++) {
        const boundary = document.createElement('div');
        boundary.className = 'lane-boundary';
        boundary.style.position = 'absolute';
        boundary.style.left = '0';
        boundary.style.right = '0';
        boundary.style.height = '1px';
        boundary.style.top = `${(i + 1) * laneHeight}px`;
        boundary.style.backgroundColor = 'rgba(255, 255, 255, 0.1)'; // –µ–¥–≤–∞ –∑–∞–º–µ—Ç–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã
        boundary.style.pointerEvents = 'none';
        boundary.style.zIndex = '500';
        track.appendChild(boundary);
      }
      
      // –°–æ–∑–¥–∞–µ–º —Ñ–∏–Ω–∏—à–Ω—É—é –ª–∏–Ω–∏—é
      const finishLine = document.createElement('div');
      finishLine.className = 'finish-line';
      finishLine.style.position = 'absolute';
      finishLine.style.right = '0';
      finishLine.style.top = '0';
      finishLine.style.bottom = '0';
      finishLine.style.width = '4px';
      finishLine.style.backgroundColor = '#ffd700'; // –∑–æ–ª–æ—Ç–æ–π —Ü–≤–µ—Ç
      finishLine.style.boxShadow = '0 0 10px #ffd700';
      finishLine.style.pointerEvents = 'none';
      finishLine.style.zIndex = '600';
      finishLine.style.animation = 'finishLinePulse 2s ease-in-out infinite';
      track.appendChild(finishLine);
    }

    /* === –ö–ª–∏–µ–Ω—Ç—Å–∫–∏–µ –∫–æ–ª–ª–∏–∑–∏–∏ ‚Äî –æ—Ç–∫–ª—é—á–∏—Ç—å === */
    // –µ—Å–ª–∏ —É —Ç–µ–±—è –≥–¥–µ-—Ç–æ –±—ã–ª–æ checkPlaneRaceCollisions(), –ø—Ä–æ—Å—Ç–æ —É–±–µ—Ä–∏ –≤—ã–∑–æ–≤—ã.
    // –ò—Å—Ç–∏–Ω–∞ —Ç–µ–ø–µ—Ä—å –≤—Å–µ–≥–¥–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ. –ù–∞ –∫–ª–∏–µ–Ω—Ç–µ ‚Äî —Ç–æ–ª—å–∫–æ –∞–Ω–∏–º–∞—Ü–∏—è –∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ.
    function checkPlaneRaceCollisions() {
      // –û—Ç–∫–ª—é—á–µ–Ω–æ - –∫–æ–ª–ª–∏–∑–∏–∏ —Ç–µ–ø–µ—Ä—å —Ç–æ–ª—å–∫–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
      return;
    }

    /* === –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π —Å —Å–µ—Ä–≤–µ—Ä–∞ === */
    // –°–æ–±—ã—Ç–∏—è —Ç–µ–ø–µ—Ä—å –ø—Ä–∏—Ö–æ–¥—è—Ç —á–µ—Ä–µ–∑ SSE (Server-Sent Events)
    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ es.addEventListener('racePlanState', ...)

    // —Å–µ—Ä–≤–µ—Ä –ø—Ä–∏—Å–ª–∞–ª –∫–æ–ª–ª–∏–∑–∏—é –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞
    window.addEventListener('racePlanCollision', (ev) => {
      const { playerId, lives } = ev.detail;
      console.log(`Collision event received for player ${playerId}, lives: ${lives}`);
      
      const p = STATE.players.get(playerId);
      if (!p) {
        console.log(`Player ${playerId} not found in STATE.players`);
        return;
      }

      // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–π
      if (lives !== undefined) {
        updateLivesDisplay(playerId, lives);
      }

      // –î–æ–±–∞–≤–ª—è–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –∫–æ–ª–ª–∏–∑–∏–∏ –∫ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–º—É —ç–ª–µ–º–µ–Ω—Ç—É .avatar
      const inner = p.el.querySelector('.avatar');
      if (!inner) return;
      
      inner.classList.add('collision');
      setTimeout(() => {
        inner.classList.remove('collision');
      }, 500);
    });


    function createObstacleEl(id, lane, xStart, type) {
      const track = document.querySelector('#racePlanArea');

      const el = document.createElement('div');
      el.className = `obstacle ${type}`;
      el.dataset.id = id;

      const L = Math.max(0, Math.min(2, (lane|0))); // clamp lane
      el.dataset.lane = String(L);

      // –Ω–∞—á–∞–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
      const y = laneCenterY(L);
      const x = xStart || track.clientWidth + 100;
      
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º translate3d –¥–ª—è –∞–ø–ø–∞—Ä–∞—Ç–Ω–æ–≥–æ —É—Å–∫–æ—Ä–µ–Ω–∏—è
      el.style.transform = `translate3d(${Math.round(x)}px, ${y - el.clientHeight/2}px, 0)`;
      
      // –î–æ–±–∞–≤–ª—è–µ–º –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –¥–ª—è –ø–ª–∞–≤–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏
      el.style.willChange = 'transform';
      el.style.backfaceVisibility = 'hidden';
      el.style.perspective = '1000px';

      track.appendChild(el);
      return el;
    }



    function checkRacePlanFinish(player, playerId) {
      if (player.out) return;
      
      const trackEl = document.querySelector('#racePlanArea');
      if (!trackEl) return;
      
      const trackRect = trackEl.getBoundingClientRect();
      const { w } = measureAvatar(player.el);
      
      // –§–∏–Ω–∏—à –ø–æ –ü–†–ê–í–û–ú–£ –∫—Ä–∞—é –∞–≤–∞—Ç–∞—Ä–∞
      const currentLeft = (player.x || 0) - Math.round(w / 2); // –ª–µ–≤—ã–π –∫—Ä–∞–π
      const rightEdge = currentLeft + w;            // –ø—Ä–∞–≤—ã–π –∫—Ä–∞–π –∞–≤–∞—Ç–∞—Ä–∞
      
      if (rightEdge >= trackRect.width) {
        // –§–∏–Ω–∏—à! –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–±—ã—Ç–∏–µ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
        fetch('/api/race-plan/finish', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(withStreamerAuth({ winnerId: playerId }))
        }).catch(err => console.error('Error finishing race plan:', err));
        
        console.log(`Player ${playerId} finished the race! Right edge: ${rightEdge}, Track width: ${trackRect.width}`);
      }
    }

    function checkRacePlanCollisions() {
      // –ö–ª–∏–µ–Ω—Ç –±–æ–ª—å—à–µ –Ω–µ —Å—á–∏—Ç–∞–µ—Ç –∫–æ–ª–ª–∏–∑–∏–∏ ‚Äî –∏—Å—Ç–∏–Ω–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
      return;
    }

    function measureHalfSizes(el, shrink = 0.12) {
      const t = el.querySelector('.hitbox-target') || el;
      const r = t.getBoundingClientRect();
      // —á—É—Ç—å ¬´—É—Ä–µ–∂–µ–º¬ª –æ—Ç –ø—Ä–æ–∑—Ä–∞—á–Ω—ã—Ö –ø–æ–ª–µ–π PNG
      const hw = Math.max(8, Math.round((r.width  * (1 - shrink*2)) / 2));
      const hh = Math.max(8, Math.round((r.height * (1 - shrink*2)) / 2));
      return { halfW: hw, halfH: hh };
    }

    function spawnObstacle(data) {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
      const el = createObstacleEl(data.id, data.lane, data.x, data.type);
      OBST.set(data.id, { el, lane: data.lane, x: data.x, serverX: data.x });
      
      console.log(`Spawning obstacle ${data.id} in lane ${data.lane} at x:${data.x}, type: ${data.type}`);
    }

    function removeObstacle(obstacleId) {
      const rec = OBST.get(obstacleId);
      if (rec) {
        // –î–æ–±–∞–≤–ª—è–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è
        rec.el.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
        rec.el.style.opacity = '0';
        rec.el.style.transform = `${rec.el.style.transform} scale(0.5)`;
        
        // –£–¥–∞–ª—è–µ–º –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
        setTimeout(() => {
          rec.el.remove();
          OBST.delete(obstacleId);
        }, 300);
      }
    }

    function updateRacePlanLevel(userId, level) {
      // –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º 0..2
      const newLane = Math.max(0, Math.min(2, level));
      racePlanState.levels.set(userId, newLane);

      const p = STATE.players.get(userId);
      if (p) p.lane = newLane;

      if (!STATE.started) {
        // –º–æ–∂–Ω–æ —Å—Ä–∞–∑—É –ø–µ—Ä–µ—Å—Ç–∞–≤–∏—Ç—å –±–µ–∑ –∞–Ω–∏–º–∞—Ü–∏–∏, —á—Ç–æ–±—ã –∏–≥—Ä–æ–∫ ¬´–≤ –æ—Ç—Å—á—ë—Ç–µ¬ª —Å—Ç–æ—è–ª —É–∂–µ –Ω–∞ –Ω—É–∂–Ω–æ–π –ø–æ–ª–æ—Å–µ
        const el = p?.el;
        if (el) {
          const { w, h } = measureAvatar(el);
          const y = laneCenterY(newLane) - Math.round(h/2);
          const x = (p?.x ?? 50) - Math.round(w/2);
          const prev = el.style.transition;
          el.style.transition = 'none';
          el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
          requestAnimationFrame(() => (el.style.transition = prev || ''));
        }
        console.log(`Level ${newLane} set for user ${userId} (game not started yet)`);
        return; // –¥–æ —Å—Ç–∞—Ä—Ç–∞ ‚Äî –Ω–µ –¥—ë—Ä–≥–∞–µ–º –ø–ª–∞–≤–Ω—ã–µ –∞–Ω–∏–º–∞—Ü–∏–∏
      }

      // –ø–æ—Å–ª–µ —Å—Ç–∞—Ä—Ç–∞ ‚Äî –ø—Ä–æ—Å—Ç–æ —Å–º–µ–Ω–∞ lane, gameLoop —Å–∞–º –ø–µ—Ä–µ—Ä–∏—Å—É–µ—Ç
      smoothLevelTransition(userId, newLane);
      console.log(`Updated level for user ${userId}: ${newLane}`);
      
      // Update level indicator to show current level
      updateLevelIndicator(newLane);
    }

    function updateRacePlanPosition(userId, position) {
      racePlanState.positions.set(userId, position);
      const level = racePlanState.levels.get(userId) || 1;
      
      // –î–∞–¥–∏–º –¥–≤–∏–∂–∫—É –∑–Ω–∞—Ç—å —Ü–µ–ª–µ–≤—É—é –ø–æ–∑–∏—Ü–∏—é –ø–æ X:
      const p = STATE.players.get(userId);
      if (p) p.serverX = position.x;
      
      updateRacePlanAvatarPosition(userId, level);
      console.log(`Updated position for user ${userId}:`, position);
    }

    function handleRacePlanCollision(playerId, lives) {
      console.log(`[overlay] handleRacePlanCollision called for player: ${playerId}, lives: ${lives}`);
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–π
      updateLivesDisplay(playerId, lives);
      
      // –î–æ–±–∞–≤–ª—è–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –∫–æ–ª–ª–∏–∑–∏–∏ –∫ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–º—É —ç–ª–µ–º–µ–Ω—Ç—É .avatar
      const avatarEl = racePlanState.participants.get(playerId);
      if (!avatarEl) return;
      
      const inner = avatarEl.querySelector('.avatar');
      if (!inner) return;
      
      inner.classList.add('collision');
      setTimeout(() => {
        inner.classList.remove('collision');
      }, 500);
      
      // –ï—Å–ª–∏ –∂–∏–∑–Ω–∏ –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å, –ø–æ–º–µ—á–∞–µ–º –∏–≥—Ä–æ–∫–∞ –∫–∞–∫ –∏—Å–∫–ª—é—á–µ–Ω–Ω–æ–≥–æ
      if (lives <= 0) {
        const player = STATE.players.get(playerId);
        if (player) {
          player.out = true;
          avatarEl.classList.add('out');
          avatarEl.dataset.dead = '1';
        }
      }
    }

    function createLivesDisplay(userId, lives) {
      const avatarEl = racePlanState.participants.get(userId);
      if (!avatarEl) return;
      
      const livesDisplay = avatarEl.querySelector('.lives-display');
      if (!livesDisplay) return;
      
      // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–µ—Ä–¥–µ—á–∫–∏
      livesDisplay.innerHTML = '';
      
      // –°–æ–∑–¥–∞–µ–º —Å–µ—Ä–¥–µ—á–∫–∏ (–º–∞–∫—Å–∏–º—É–º 3)
      const maxLives = 3;
      for (let i = 0; i < maxLives; i++) {
        const heart = document.createElement('div');
        heart.className = 'heart';
        if (i >= lives) {
          heart.classList.add('empty');
        }
        livesDisplay.appendChild(heart);
      }
    }
    
    function updateLivesDisplay(userId, lives) {
      createLivesDisplay(userId, lives);
    }

    function handleRacePlanCollision(userId, lives) {
      const avatarEl = racePlanState.participants.get(userId);
      if (!avatarEl) return;
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–π
      updateLivesDisplay(userId, lives);
      
      // –î–æ–±–∞–≤–ª—è–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –∫–æ–ª–ª–∏–∑–∏–∏ –∫ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–º—É —ç–ª–µ–º–µ–Ω—Ç—É .avatar
      const inner = avatarEl.querySelector('.avatar');
      if (!inner) return;
      
      inner.classList.add('collision');
      setTimeout(() => {
        inner.classList.remove('collision');
      }, 500);
      
      console.log(`Collision animation for user ${userId}, lives: ${lives}`);
    }

    function endPlaneRace() {
      racePlanState.isActive = false;
      racePlanState.gameOver = true;
      STATE.started = false;
      STATE.finished = true;
      
      // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
      stopLoop();
      
      // Hide game area
      document.getElementById('racePlanArea').style.display = 'none';
      document.getElementById('levelIndicator').style.display = 'none';
      document.getElementById('racePlanWinner').style.display = 'none';
      
      // Clean up
      racePlanState.participants.forEach(avatarEl => {
        const avatar = avatarEl.querySelector('.avatar');
        if (avatar) {
          stopAvatarIntervals(avatar);
        }
        // Remove any lives displays (hearts) that might still exist
        const livesDisplay = avatarEl.querySelector('.lives-display');
        if (livesDisplay) {
          livesDisplay.remove();
        }
        avatarEl.remove();
      });
      
      racePlanState.obstacles.forEach(obstacle => obstacle.remove());
      
      // Clear state
      racePlanState.participants.clear();
      racePlanState.positions.clear();
      racePlanState.levels.clear();
      racePlanState.obstacles.clear();
      racePlanState.winner = null;
      racePlanState.gameOver = false;
      
      // –û—á–∏—â–∞–µ–º –Ω–æ–≤—ã–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
      OBST.forEach(rec => rec.el.remove());
      OBST.clear();
      STATE.players.clear();
      
      // –ì–æ—Ç–æ–≤–∏–º –∫ –Ω–æ–≤–æ–º—É —Å—Ç–∞—Ä—Ç—É
      STATE.finished = false;
    }

    function connect() {
      // Get streamer ID from URL parameters (token or legacy streamer_id)
      const urlParams = new URLSearchParams(window.location.search);
      const token = urlParams.get('token');
      const streamerId = urlParams.get('streamer_id') || urlParams.get('streamer');

      overlayAuth.token = token || null;
      overlayAuth.streamerId = streamerId ? String(streamerId) : null;

      if (!token && !streamerId) {
        console.error('[overlay] ERROR: token or streamer_id parameter is required');
        document.body.innerHTML = '<div style="color: red; font-size: 24px; text-align: center; margin-top: 50px;">ERROR: token or streamer_id parameter is required</div>';
        return;
      }
      
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–∫–µ–Ω –µ—Å–ª–∏ –µ—Å—Ç—å, –∏–Ω–∞—á–µ fallback –Ω–∞ streamer_id
      const eventUrl = token 
        ? `/overlay/events?token=${token}`
        : `/overlay/events?streamer_id=${streamerId}`;
      
      console.log(`[overlay] Connecting to: ${eventUrl}`);
      console.log(`[overlay] Using ${token ? 'token' : 'streamer_id'} authentication`);
      
      const es = new EventSource(eventUrl);
      
      es.onopen = () => {
        console.log(`[overlay] SSE connection opened to: ${eventUrl}`);
      };
      
      es.onerror = (error) => {
        console.error(`[overlay] SSE connection error:`, error);
        console.log(`[overlay] Retrying connection in 3 seconds...`);
        setTimeout(() => {
          connect();
        }, 3000);
      };
      es.addEventListener('spawn', async (e) => {
        try { 
          const data = JSON.parse(e.data); 
          const userAssets = await loadUserAvatar(data.userId);
          createAvatar({ ...data, avatarData: userAssets }); 
        } catch(_) {}
      });
      es.addEventListener('avatar:show', async (e) => {
        try { 
          const data = JSON.parse(e.data); 
          console.log('[overlay] avatar:show event received:', data);
          
          // –ò—Å–ø–æ–ª—å–∑—É–µ–º avatarData –∏–∑ —Å–æ–±—ã—Ç–∏—è, –µ—Å–ª–∏ –µ—Å—Ç—å, –∏–Ω–∞—á–µ –∑–∞–≥—Ä—É–∂–∞–µ–º
          let userAssets = data.avatarData;
          if (!userAssets) {
            userAssets = await loadUserAvatar(data.twitchUserId);
          }
          
          createAvatar({ 
            userId: data.twitchUserId,
            displayName: data.displayName || 'Unknown',
            color: data.color,
            avatarData: userAssets,
            ts: Date.now(),
            source: data.source,
            amount: data.amount,
            message: data.message,
            currency: data.currency
          }); 
        } catch(err) {
          console.error('[overlay] Error handling avatar:show event:', err);
        }
      });
      es.addEventListener('despawn', (e) => {
        try { const data = JSON.parse(e.data); removeAvatar(data.userId); } catch(_) {}
      });
      es.addEventListener('move', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          console.log('[overlay] move event received:', data);
          
          // Use messageLength as primary source for distance calculation
          let messageCount = data.messageCount;
          
          if (!messageCount && data.messageLength) {
            // Use messageLength directly for distance calculation
            // 1 character = 1 message unit
            messageCount = Math.max(1, data.messageLength);
            console.log('[overlay] Using messageLength as messageCount:', data.messageLength, '->', messageCount);
          } else if (!messageCount && data.distance) {
            // Fallback to distance but scale it down for reasonable movement
            // 200px distance = 1 message, so scale accordingly
            messageCount = Math.max(1, Math.round(Math.abs(data.distance) / 200));
            console.log('[overlay] Using distance as messageCount:', data.distance, '->', messageCount);
          }
          
          moveAvatar(data.userId, messageCount || 1); 
        } catch(err) {
          console.error('[overlay] Error handling move event:', err);
        }
      });
      es.addEventListener('stopWalking', (e) => {
        try { const data = JSON.parse(e.data); stopWalkingAnimation(data.userId); } catch(_) {}
      });
      es.addEventListener('emoji', (e) => {
        try { const data = JSON.parse(e.data); showEmoji(data.userId, data.emoji); } catch(_) {}
      });
      es.addEventListener('sign', (e) => {
        try { const data = JSON.parse(e.data); showEmoji(data.userId, data.emoji); } catch(_) {}
      });
      es.addEventListener('hi', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          console.log('[overlay] hi event received:', data);
          showHi(data.userId); 
        } catch(err) {
          console.error('[overlay] Error parsing hi event:', err);
        }
      });
      es.addEventListener('laugh', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          console.log('[overlay] laugh event received:', data);
          showLaugh(data.userId); 
        } catch(err) {
          console.error('[overlay] Error parsing laugh event:', err);
        }
      });
      es.addEventListener('question', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          console.log('[overlay] question event received:', data);
          showQuestion(data.userId); 
        } catch(err) {
          console.error('[overlay] Error parsing question event:', err);
        }
      });
      es.addEventListener('gift', (e) => {
        try { const data = JSON.parse(e.data); showGift(data.userId, data.giftData); } catch(_) {}
      });
      es.addEventListener('clearAvatarCache', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          // Clear user avatar cache
          userAvatars.delete(data.userId);
          console.log(`Cleared avatar cache for user: ${data.userId}`);
        } catch(_) {}
      });
      es.addEventListener('avatarUpdate', async (e) => {
        try { 
          const data = JSON.parse(e.data); 
          console.log(`Avatar update event received for user: ${data.userId}`, data);
          
          // Clear user avatar cache to force reload
          userAvatars.delete(data.userId);
          console.log(`Cleared avatar cache for user: ${data.userId}`);
          
          // Check if avatar exists on overlay
          const existingAvatar = active.get(data.userId);
          console.log(`Existing avatar found:`, !!existingAvatar);
          
          if (existingAvatar) {
            // Get current avatar position and state
            const currentLeft = existingAvatar.style.left;
            const currentClasses = existingAvatar.className;
            const currentDisplayName = existingAvatar.dataset.displayName;
            const currentColor = existingAvatar.dataset.color;
            
            // Load new avatar data
            console.log(`Loading new avatar data for user: ${data.userId}`);
            const newAvatarData = await loadUserAvatar(data.userId);
            console.log(`New avatar data loaded:`, newAvatarData);
            
            // Create new avatar with updated data (createAvatar will remove the old one)
            console.log(`Recreating avatar for user: ${data.userId}`);
            createAvatar({ 
              userId: data.userId, 
              displayName: currentDisplayName, 
              color: currentColor, 
              avatarData: newAvatarData 
            });
            
            // Restore position and state
            const newAvatar = active.get(data.userId);
            if (newAvatar) {
              newAvatar.style.left = currentLeft;
              newAvatar.className = currentClasses;
              console.log(`Avatar recreated and restored for user: ${data.userId}`);
            }
          } else {
            console.log(`No existing avatar found for user: ${data.userId}`);
          }
        } catch(err) {
          console.error('Error updating avatar:', err);
        }
      });
      es.addEventListener('raceStart', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          console.log('Race start event received:', data);
          startRace(data);
        } catch(err) {
          console.error('Error parsing race start event:', err);
        }
      });
      es.addEventListener('raceSpeedUpdate', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          updateRaceSpeed(data.participantId, data.speedModifier);
        } catch(_) {}
      });
      es.addEventListener('raceFinish', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          finishRace(data.winner);
        } catch(_) {}
      });
      
      // Food Game Events
      es.addEventListener('foodGameStart', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          console.log('Food game start event received:', data);
          startFoodGame(data);
        } catch(err) {
          console.error('Error parsing food game start event:', err);
        }
      });
      es.addEventListener('foodGameMonitoring', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          console.log('Food game monitoring event received:', data);
          startFoodGameMonitoring(data);
        } catch(err) {
          console.error('Error parsing food game monitoring event:', err);
        }
      });
      es.addEventListener('foodGameDirectionUpdate', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          updateFoodGameDirection(data.userId, data.direction);
        } catch(_) {}
      });
      es.addEventListener('carrotSpawn', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          spawnCarrot(data);
        } catch(_) {}
      });
      es.addEventListener('carrotRemove', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          removeCarrot(data.id);
        } catch(_) {}
      });
      es.addEventListener('foodGameEnd', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          finishFoodGame(data);
        } catch(_) {}
      });
      es.addEventListener('foodGameScoreUpdate', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          updateFoodGameScore(data.userId, data.score);
        } catch(_) {}
      });
      es.addEventListener('foodGameSpeedUpdate', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          updateFoodGameSpeed(data.userId, data.speedModifier);
        } catch(_) {}
      });
      
      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–º–µ–Ω—ã —Å–æ—Å—Ç–æ—è–Ω–∏—è –∞–≤–∞—Ç–∞—Ä–∞ (normal/tired)
      es.addEventListener('avatarStateChanged', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          updateAvatarState(data.userId, data.state);
        } catch(_) {}
      });
      
      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —É–¥–∞–ª–µ–Ω–∏—è –∞–≤–∞—Ç–∞—Ä–∞
      es.addEventListener('avatarRemoved', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          removeAvatar(data.userId);
        } catch(_) {}
      });

      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∞–≤–∞—Ç–∞—Ä–∞ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
      es.addEventListener('avatarUpdated', async (e) => {
        try { 
          const data = JSON.parse(e.data); 
          console.log(`Avatar update received for user: ${data.userId}`, data.avatarData);
          
          // Update user avatar cache with new data
          if (data.avatarData) {
            // Extract IDs from the full names
            const bodyId = data.avatarData.body_skin ? data.avatarData.body_skin.replace('body_skin_', '') : '1';
            const faceId = data.avatarData.face_skin ? data.avatarData.face_skin.replace('face_skin_', '') : '1';
            const clothesId = data.avatarData.clothes_type ? data.avatarData.clothes_type.replace('clothes_type_', '') : '1';
            const othersId = data.avatarData.others_type ? data.avatarData.others_type.replace('others_', '') : '1';
            
            const userAssets = {
              body: `/parts/body/${data.avatarData.body_skin || 'body_skin_1'}.png`,
              face: `/parts/face/${data.avatarData.face_skin || 'face_skin_1'}.png`,
              clothes: `/parts/clothes/${data.avatarData.clothes_type || 'clothes_type_1'}.png`,
              others: `/parts/others/${data.avatarData.others_type || 'others_1'}.png`,
              bodyId: bodyId,
              faceId: faceId,
              clothesId: clothesId,
              othersId: othersId
            };
            
            userAvatars.set(data.userId, userAssets);
            console.log(`Updated avatar cache for user: ${data.userId}`);
          }
          
          // If user has active avatar, update it immediately
          if (active.has(data.userId)) {
            console.log(`Updating active avatar appearance for user: ${data.userId}`);
            const existingAvatar = active.get(data.userId);
            const currentLeft = existingAvatar.style.left;
            const currentClasses = existingAvatar.className;
            const currentDisplayName = existingAvatar.dataset.displayName;
            const currentColor = existingAvatar.dataset.color;
            
            // Create new avatar with updated data (createAvatar will remove the old one)
            console.log(`Recreating avatar with new appearance for user: ${data.userId}`);
            createAvatar({ 
              userId: data.userId, 
              displayName: currentDisplayName, 
              color: currentColor, 
              avatarData: userAvatars.get(data.userId) || await loadUserAvatar(data.userId)
            });
            
            // Restore position and state
            const newAvatar = active.get(data.userId);
            if (newAvatar) {
              newAvatar.style.left = currentLeft;
              newAvatar.className = currentClasses;
              console.log(`Avatar appearance updated and restored for user: ${data.userId}`);
            }
          } else {
            console.log(`No active avatar found for user: ${data.userId}, cache updated for future spawns`);
          }
        } catch(err) {
          console.error('[overlay] Error handling avatarUpdated event:', err);
        }
      });
      
      // Plane Race Events
      es.addEventListener('racePlanStart', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          console.log('Plane race start event received:', data);
          console.log('Participants count:', data.participants ? data.participants.length : 'undefined');
          console.log('Countdown:', data.countdown);
          
          // –ï—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –ø—Ä–∏—Å—ã–ª–∞–µ—Ç levels/lives –≤ —Å—Ç–∞—Ä—Ç–µ, –ø—Ä–æ—Å—Ç–∞–≤–ª—è–µ–º –∏—Ö
          if (data.levels) {
            Object.entries(data.levels).forEach(([uid, lvl]) => {
              racePlanState.levels.set(uid, lvl|0);
            });
          }
          
          startRacePlan(data);
        } catch(err) {
          console.error('Error parsing plane race start event:', err);
        }
      });
      es.addEventListener('racePlanMonitoring', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          console.log('Plane race monitoring event received:', data);
          // Initialize positions, levels, and lives
          data.participants.forEach(userId => {
            if (data.positions[userId]) {
              racePlanState.positions.set(userId, data.positions[userId]);
            }
            if (data.levels[userId]) {
              racePlanState.levels.set(userId, data.levels[userId]);
            }
            // REMOVED: Lives display creation to prevent red hearts from appearing
            // if (data.lives && data.lives[userId]) {
            //   createLivesDisplay(userId, data.lives[userId]);
            // }
          });
        } catch(err) {
          console.error('Error parsing plane race monitoring event:', err);
        }
      });
      es.addEventListener('racePlanLevelUpdate', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          updateRacePlanLevel(data.userId, data.level);
        } catch(_) {}
      });
      es.addEventListener('racePlanPositionUpdate', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          updateRacePlanPosition(data.userId, data.position);
        } catch(_) {}
      });
      es.addEventListener('obstacleSpawn', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          spawnObstacle(data);
        } catch(_) {}
      });
      es.addEventListener('racePlanObstacleSpawn', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          spawnObstacle(data);
        } catch(_) {}
      });
      es.addEventListener('obstacleRemove', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          removeObstacle(data.id);
        } catch(_) {}
      });
      es.addEventListener('racePlanObstacleBatch', (e) => {
        try { 
          const arr = JSON.parse(e.data); // [{id, x, lane, type}]
          arr.forEach(o => {
            let rec = OBST.get(o.id);
            if (!rec) {
              const el = createObstacleEl(o.id, o.lane, o.x, o.type);
              rec = { el, lane: o.lane, x: o.x, serverX: o.x };
              OBST.set(o.id, rec);
              return;
            }
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ü–µ–ª–µ–≤—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
            rec.lane = o.lane;
            rec.serverX = o.x; // <- —Ü–µ–ª–µ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
          });
        } catch(_) {}
      });
      es.addEventListener('racePlanState', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          console.log('=== RECEIVED racePlanState SSE event ===');
          console.log('Data:', data);
          
          const { players, started, finished } = data;
          STATE.started = started;
          STATE.finished = finished;
          
          players.forEach(pl => {
            let p = STATE.players.get(pl.id);
            if (!p) {
              // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é —Å–æ–∑–¥–∞–Ω–∏—è –∞–≤–∞—Ç–∞—Ä–∞
              const existingEl = document.getElementById(`race-plan-avatar-${pl.id}`);
              if (existingEl) {
                p = { el: existingEl, lane: pl.lane ?? 1, x: pl.x ?? 50, serverX: pl.x ?? 50, out: false };
                STATE.players.set(pl.id, p);
              }
            }
            
            if (p) {
              // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
              p.lane = pl.lane ?? 1;
              p.serverX = pl.x ?? 50; // —Ü–µ–ª–µ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è —Å —Å–µ—Ä–≤–µ—Ä–∞
              p.out = !!pl.out;
              p.lives = pl.lives ?? 3;
              
              // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–π
              updateLivesDisplay(pl.id, p.lives);
              
              if (p.out) {
                p.el.classList.add('out');
                p.el.dataset.dead = '1';
              } else {
                p.el.classList.remove('out');
                delete p.el.dataset.dead;
              }
              
            }
          });
        } catch(err) {
          console.error('Error parsing racePlanState event:', err);
        }
      });
      es.addEventListener('racePlanCollision', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          handleRacePlanCollision(data.playerId || data.userId, data.lives);
        } catch(_) {}
      });
      es.addEventListener('racePlanEnd', (e) => {
        try { 
          const data = JSON.parse(e.data); 
          console.log('Plane race end event received:', data);
          
          // Show winner or no winners message
          const winnerEl = document.getElementById('racePlanWinner');
          if (data.noWinners) {
            winnerEl.textContent = `üíÄ –ü–û–ë–ï–î–ò–¢–ï–õ–ï–ô –ù–ï–¢!`;
            winnerEl.style.color = '#ff6b6b'; // –∫—Ä–∞—Å–Ω—ã–π —Ü–≤–µ—Ç –¥–ª—è "–Ω–µ—Ç –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π"
          } else {
            winnerEl.textContent = `üèÜ ${data.winnerName} –ü–û–ë–ï–î–ò–õ!`;
            winnerEl.style.color = '#ffd700'; // –∑–æ–ª–æ—Ç–æ–π —Ü–≤–µ—Ç –¥–ª—è –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
          }
          winnerEl.style.display = 'block';
          
          // Clean up after 5 seconds
          setTimeout(() => {
            endPlaneRace();
          }, 5000);
        } catch(_) {}
      });
      
      es.onerror = () => { es.close(); setTimeout(connect, 2000); };
    }

    // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª —Å—Ä–∞–∑—É –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
    startLoop();
    
    connect();
  </script>
</body>
</html>


